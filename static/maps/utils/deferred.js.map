{"version":3,"sources":["utils/deferred.js"],"names":["define","Utils","Backbone","Model","extend","initialize","execute","callback","self","this","uid","length","active","id","process","$","Deferred","promise","always","Galaxy","has_deferred","state","charAt","toUpperCase","slice","when","last","emit","debug","resolve","i","reset","ready","isEmptyObject"],"mappings":"aAGAA,QAAQ,eAAgB,SAASC,GAC7B,OAAOC,SAASC,MAAMC,QADlBC,WAAA,WACGH,KAAAA,UACHG,KAAAA,KAAY,MAQZC,QAAS,SAASC,GACd,IAAIC,EAAOC,KADfH,EAASL,EAAAS,MACDF,EAAJD,EAAAI,OAAA,EAKAF,KAAKG,OAAOC,IAAM,EAGlB,IAAIC,EAAUC,EAAEC,WADhBF,EAAAG,UAAAC,OAAA,kBACIJ,EAAYE,OAAAA,GAChBF,GACIK,OAAOX,KAAKI,MACZQ,sBAFJX,KAAAY,QAMiBC,OAAO,GAQxBC,cACAd,KAAkBS,QAAOM,MAAA,GACZZ,IACLQ,KASHL,EAAAU,KAAAhB,KAAAiB,MAAAR,OAAA,WAXLV,EAAAI,OAAAC,IAaKa,GA/CgBP,OAAAQ,KAAAC,MAsCL,sBAYpB,WAAAf,GAEON,EAAAO,IACIa,GAAWb,EAAAe,WAEdf,EAAYgB,WARhBrB,KAAKiB,KAAOZ,EAAQG,WAgBvBc,MAAA,WA/DLZ,OAAAQ,KAAAC,MAAA,sBAAA,SADJ,IAAA,IAAAE,KAAArB,KAAAG,OAwDgBH,KAAKG,OAAOkB,IAAK,GAMzBE,MAAO,WACH,OAAOjB,EAAEkB,cAAcxB,KAAKG","file":"../../scripts/utils/deferred.js","sourcesContent":["/**\n *  This class defines a queue to ensure that multiple deferred callbacks are executed sequentially.\n */\ndefine([\"utils/utils\"], function(Utils) {\n    return Backbone.Model.extend({\n        initialize: function() {\n            this.active = {};\n            this.last = null;\n        },\n\n        /** Adds a callback to the queue. Upon execution a deferred object is parsed to the callback i.e. callback( deferred ).\n     *  If the callback does not take any arguments, the deferred is resolved instantly.\n    */\n        execute: function(callback) {\n            var self = this;\n            var id = Utils.uid();\n            var has_deferred = callback.length > 0;\n\n            // register process\n            this.active[id] = true;\n\n            // deferred process\n            var process = $.Deferred();\n            process.promise().always(function() {\n                delete self.active[id];\n                has_deferred &&\n                    Galaxy.emit.debug(\n                        \"deferred::execute()\",\n                        this.state()\n                            .charAt(0)\n                            .toUpperCase() +\n                            this.state().slice(1) +\n                            \" \" +\n                            id\n                    );\n            });\n\n            // deferred queue\n            $.when(this.last).always(function() {\n                if (self.active[id]) {\n                    has_deferred &&\n                        Galaxy.emit.debug(\n                            \"deferred::execute()\",\n                            \"Running \" + id\n                        );\n                    callback(process);\n                    !has_deferred && process.resolve();\n                } else {\n                    process.reject();\n                }\n            });\n            this.last = process.promise();\n        },\n\n        /** Resets the promise queue. All currently queued but unexecuted callbacks/promises will be rejected.\n    */\n        reset: function() {\n            Galaxy.emit.debug(\"deferred::execute()\", \"Reset\");\n            for (var i in this.active) {\n                this.active[i] = false;\n            }\n        },\n\n        /** Returns true if all processes are done.\n    */\n        ready: function() {\n            return $.isEmptyObject(this.active);\n        }\n    });\n});\n"]}