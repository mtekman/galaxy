{"version":3,"sources":["utils/graph.js"],"names":["define","matches","d","d2","k","hasOwnProperty","iterate","obj","propsOrFn","fn","undefined","props","_typeof","returned","key","index","value","push","Edge","source","target","data","self","this","Vertex","name","Graph","directed","options","read","prototype","toString","toJSON","json","eachEdge","edges","GraphSearch","graph","processFns","vertex","search","vertexEarly","from","edge","_cache","start","_search","discovered","searchTree","_searchTree","Object","keys","map","vertices","BreadthFirstSearch","call","constructor","queue","length","shift","adj","discoverAdjacent","vertexLate","DepthFirstSearch","discoverAdjacentVertices","adjacent","sourceVertex","recurse","time","eachAdjacent","exitTimes","entryTimes","window","allowReflexiveEdges","readNodesAndLinks","nodes","forEach","node","createVertex","links","i","sourceName","targetName","readVerticesAndEdges","createEdge","isReflexive","targetVertex","degree","numEdges","Array","concat","apply","eachVertex","print","console","strings","log","toDOT","toNodesAndLinks","to","indeces","join","toVerticesAndEdges","breadthFirstSearch","breadthFirstSearchTree","depthFirstSearch","depthFirstSearchTree","weakComponents","undiscovered","searchGraph","components","weakComponentGraph","undiscoveredVertex","filter","hasBeenReversed","swap","vertexName","reduction","curr","component","reduce","weakComponentGraphArray","Math","numVerts","randGraph","randRange","floor","random","range"],"mappings":"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","file":"../../scripts/utils/graph.js","sourcesContent":["define([], function() {\n    /* ============================================================================\nTODO:\n\n============================================================================ */\n    //TODO: go ahead and move to underscore...\n    /** call fn on each key/value in d */\n    function each(d, fn) {\n        for (var k in d) {\n            if (d.hasOwnProperty(k)) {\n                fn(d[k], k, d);\n            }\n        }\n    }\n\n    /** copy key/values from d2 to d overwriting if present */\n    function extend(d, d2) {\n        for (var k in d2) {\n            if (d2.hasOwnProperty(k)) {\n                d[k] = d2[k];\n            }\n        }\n        return d;\n    }\n\n    /** deep equal of two dictionaries */\n    function matches(d, d2) {\n        for (var k in d2) {\n            if (d2.hasOwnProperty(k)) {\n                if (!d.hasOwnProperty(k) || d[k] !== d2[k]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /** map key/values in obj\n *      if propsOrFn is an object, return only those k/v that match the object\n *      if propsOrFn is function, call the fn and returned the mapped values from it\n */\n    function iterate(obj, propsOrFn) {\n        var fn = typeof propsOrFn === \"function\" ? propsOrFn : undefined,\n            props = typeof propsOrFn === \"object\" ? propsOrFn : undefined,\n            returned = [],\n            index = 0;\n        for (var key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                var value = obj[key];\n                if (fn) {\n                    returned.push(fn.call(value, value, key, index));\n                } else if (props) {\n                    //TODO: break out to sep?\n                    if (typeof value === \"object\" && matches(value, props)) {\n                        returned.push(value);\n                    }\n                } else {\n                    returned.push(value);\n                }\n                index += 1;\n            }\n        }\n        return returned;\n    }\n\n    // ============================================================================\n    /** A graph edge containing the name/id of both source and target and optional data\n */\n    function Edge(source, target, data) {\n        var self = this;\n        self.source = source !== undefined ? source : null;\n        self.target = target !== undefined ? target : null;\n        self.data = data || null;\n        //if( typeof data === 'object' ){\n        //    extend( self, data );\n        //}\n        return self;\n    }\n    /** String representation */\n    Edge.prototype.toString = function() {\n        return this.source + \"->\" + this.target;\n    };\n\n    /** Return a plain object representing this edge */\n    Edge.prototype.toJSON = function() {\n        //TODO: this is safe in most browsers (fns will be stripped) - alter tests to incorporate this in order to pass data\n        //return this;\n        var json = {\n            source: this.source,\n            target: this.target\n        };\n        if (this.data) {\n            json.data = this.data;\n        }\n        return json;\n    };\n\n    // ============================================================================\n    /** A graph vertex with a (unique) name/id and optional data.\n *      A vertex contains a list of Edges (whose sources are this vertex) and maintains the degree.\n */\n    function Vertex(name, data) {\n        var self = this;\n        self.name = name !== undefined ? name : \"(unnamed)\";\n        self.data = data || null;\n        self.edges = {};\n        self.degree = 0;\n        return self;\n    }\n\n    /** String representation */\n    Vertex.prototype.toString = function() {\n        return \"Vertex(\" + this.name + \")\";\n    };\n\n    //TODO: better name w no collision for either this.eachEdge or this.edges\n    /** Iterate over each edge from this vertex */\n    Vertex.prototype.eachEdge = function(propsOrFn) {\n        return iterate(this.edges, propsOrFn);\n    };\n\n    /** Return a plain object representing this vertex */\n    Vertex.prototype.toJSON = function() {\n        //return this;\n        return {\n            name: this.name,\n            data: this.data\n        };\n    };\n\n    // ============================================================================\n    /** Base (abstract) class for Graph search algorithms.\n *      Pass in the graph to search\n *      and an optional dictionary containing the 3 vertex/edge processing fns listed below.\n */\n    var GraphSearch = function(graph, processFns) {\n        var self = this;\n        self.graph = graph;\n\n        self.processFns = processFns || {\n            vertexEarly: function(vertex, search) {\n                //console.debug( 'processing vertex:', vertex.name, vertex );\n            },\n            edge: function(from, edge, search) {\n                //console.debug( this, 'edge:', from, edge, search );\n            },\n            vertexLate: function(vertex, search) {\n                //console.debug( this, 'vertexLate:', vertex, search );\n            }\n        };\n\n        self._cache = {};\n        return self;\n    };\n\n    /** Search interface where start is the vertex (or the name/id of the vertex) to begin the search at\n *      This public interface caches searches and returns the cached version if it's already been done.\n */\n    GraphSearch.prototype.search = function _search(start) {\n        var self = this;\n        if (start in self._cache) {\n            return self._cache[start];\n        }\n        if (!(start instanceof Vertex)) {\n            start = self.graph.vertices[start];\n        }\n        return (self._cache[start.name] = self._search(start));\n    };\n\n    /** Actual search (private) function (abstract here) */\n    GraphSearch.prototype._search = function __search(start, search) {\n        search = search || {\n            discovered: {},\n            //parents : {},\n            edges: []\n        };\n        return search;\n    };\n\n    /** Searches graph from start and returns a search tree of the results */\n    GraphSearch.prototype.searchTree = function _searchTree(start) {\n        return this._searchTree(this.search(start));\n    };\n\n    /** Helper fn that returns a graph (a search tree) based on the search object passed in (does not actually search) */\n    GraphSearch.prototype._searchTree = function __searchTree(search) {\n        var self = this;\n        return new Graph(true, {\n            edges: search.edges,\n            vertices: Object.keys(search.discovered).map(function(key) {\n                return self.graph.vertices[key].toJSON();\n            })\n        });\n    };\n\n    // ============================================================================\n    /** Breadth first search algo.\n */\n    var BreadthFirstSearch = function(graph, processFns) {\n        var self = this;\n        GraphSearch.call(this, graph, processFns);\n        return self;\n    };\n    BreadthFirstSearch.prototype = new GraphSearch();\n    BreadthFirstSearch.prototype.constructor = BreadthFirstSearch;\n\n    /** (Private) implementation of BFS */\n    BreadthFirstSearch.prototype._search = function __search(start, search) {\n        search = search || {\n            discovered: {},\n            //parents : {},\n            edges: []\n        };\n\n        var self = this,\n            queue = [];\n\n        function discoverAdjacent(adj, edge) {\n            var source = this;\n            if (self.processFns.edge) {\n                self.processFns.edge.call(self, source, edge, search);\n            }\n            if (!search.discovered[adj.name]) {\n                //console.debug( '\\t\\t\\t', adj.name, 'is undiscovered:', search.discovered[ adj.name ] );\n                search.discovered[adj.name] = true;\n                //search.parents[ adj.name ] = source;\n                search.edges.push({ source: source.name, target: adj.name });\n                //console.debug( '\\t\\t\\t queuing undiscovered: ', adj );\n                queue.push(adj);\n            }\n        }\n\n        //console.debug( 'BFS starting. start:', start );\n        search.discovered[start.name] = true;\n        queue.push(start);\n        while (queue.length) {\n            var vertex = queue.shift();\n            //console.debug( '\\t Queue is shifting. Current:', vertex, 'queue:', queue );\n            if (self.processFns.vertexEarly) {\n                self.processFns.vertexEarly.call(self, vertex, search);\n            }\n            self.graph.eachAdjacent(vertex, discoverAdjacent);\n            if (self.processFns.vertexLate) {\n                self.processFns.vertexLate.call(self, vertex, search);\n            }\n        }\n        //console.debug( 'search.edges:', JSON.stringify( search.edges ) );\n        return search;\n    };\n\n    // ============================================================================\n    /** Depth first search algorithm.\n */\n    var DepthFirstSearch = function(graph, processFns) {\n        var self = this;\n        GraphSearch.call(this, graph, processFns);\n        return self;\n    };\n    DepthFirstSearch.prototype = new GraphSearch();\n    DepthFirstSearch.prototype.constructor = DepthFirstSearch;\n\n    /** (Private) implementation of DFS */\n    DepthFirstSearch.prototype._search = function(start, search) {\n        //console.debug( 'depthFirstSearch:', start );\n        search = search || {\n            discovered: {},\n            //parents    : {},\n            edges: [],\n            entryTimes: {},\n            exitTimes: {}\n        };\n        var self = this,\n            time = 0;\n\n        // discover verts adjacent to the source (this):\n        //  processing each edge, saving the edge to the tree, and caching the reverse path with parents\n        function discoverAdjacentVertices(adjacent, edge) {\n            //console.debug( '\\t\\t adjacent:', adjacent, 'edge:', edge );\n            var sourceVertex = this;\n            if (self.processFns.edge) {\n                self.processFns.edge.call(self, sourceVertex, edge, search);\n            }\n            if (!search.discovered[adjacent.name]) {\n                //search.parents[ adjacent.name ] = sourceVertex;\n                search.edges.push({\n                    source: sourceVertex.name,\n                    target: adjacent.name\n                });\n                recurse(adjacent);\n            }\n        }\n\n        // use function stack for DFS stack process verts, times, and discover adjacent verts (recursing into them)\n        function recurse(vertex) {\n            //console.debug( '\\t recursing into: ', vertex );\n            search.discovered[vertex.name] = true;\n            if (self.processFns.vertexEarly) {\n                self.processFns.vertexEarly.call(self, vertex, search);\n            }\n            search.entryTimes[vertex.name] = time++;\n\n            self.graph.eachAdjacent(vertex, discoverAdjacentVertices);\n\n            if (self.processFns.vertexLate) {\n                self.processFns.vertexLate.call(self, vertex, search);\n            }\n            search.exitTimes[vertex.name] = time++;\n        }\n        // begin recursion with the desired start\n        recurse(start);\n\n        return search;\n    };\n\n    // ============================================================================\n    /** A directed/non-directed graph object.\n */\n    function Graph(directed, data, options) {\n        //TODO: move directed to options\n        this.directed = directed || false;\n        return this.init(options).read(data);\n    }\n    window.Graph = Graph;\n\n    /** Set up options and instance variables */\n    Graph.prototype.init = function(options) {\n        options = options || {};\n        var self = this;\n\n        self.allowReflexiveEdges = options.allowReflexiveEdges || false;\n\n        self.vertices = {};\n        self.numEdges = 0;\n        return self;\n    };\n\n    /** Read data from the plain object data - both in d3 form (nodes and links) or vertices and edges */\n    Graph.prototype.read = function(data) {\n        if (!data) {\n            return this;\n        }\n        var self = this;\n        if (data.hasOwnProperty(\"nodes\")) {\n            return self.readNodesAndLinks(data);\n        }\n        if (data.hasOwnProperty(\"vertices\")) {\n            return self.readVerticesAndEdges(data);\n        }\n        return self;\n    };\n\n    //TODO: the next two could be combined\n    /** Create the graph using a list of nodes and a list of edges (where source and target are indeces into nodes) */\n    Graph.prototype.readNodesAndLinks = function(data) {\n        if (!(data && data.hasOwnProperty(\"nodes\"))) {\n            return this;\n        }\n        //console.debug( 'readNodesAndLinks:', data );\n        //console.debug( 'data:\\n' + JSON.stringify( data, null, '  ' ) );\n        var self = this;\n        data.nodes.forEach(function(node) {\n            self.createVertex(node.name, node.data);\n        });\n        //console.debug( JSON.stringify( self.vertices, null, '  ' ) );\n\n        (data.links || []).forEach(function(edge, i) {\n            var sourceName = data.nodes[edge.source].name,\n                targetName = data.nodes[edge.target].name;\n            self.createEdge(sourceName, targetName, self.directed);\n        });\n        //self.print();\n        //console.debug( JSON.stringify( self.toNodesAndLinks(), null, '  ' ) );\n        return self;\n    };\n\n    /** Create the graph using a list of nodes and a list of edges (where source and target are names of nodes) */\n    Graph.prototype.readVerticesAndEdges = function(data) {\n        if (!(data && data.hasOwnProperty(\"vertices\"))) {\n            return this;\n        }\n        //console.debug( 'readVerticesAndEdges:', data );\n        //console.debug( 'data:\\n' + JSON.stringify( data, null, '  ' ) );\n        var self = this;\n        data.vertices.forEach(function(node) {\n            self.createVertex(node.name, node.data);\n        });\n        //console.debug( JSON.stringify( self.vertices, null, '  ' ) );\n\n        (data.edges || []).forEach(function(edge, i) {\n            self.createEdge(edge.source, edge.target, self.directed);\n        });\n        //self.print();\n        //console.debug( JSON.stringify( self.toNodesAndLinks(), null, '  ' ) );\n        return self;\n    };\n\n    /** Return the vertex with name, creating it if necessary */\n    Graph.prototype.createVertex = function(name, data) {\n        //console.debug( 'createVertex:', name, data );\n        if (this.vertices[name]) {\n            return this.vertices[name];\n        }\n        return (this.vertices[name] = new Vertex(name, data));\n    };\n\n    /** Create an edge in vertex named sourceName to targetName (optionally adding data to it)\n *      If directed is false, create a second edge from targetName to sourceName.\n */\n    Graph.prototype.createEdge = function(\n        sourceName,\n        targetName,\n        directed,\n        data\n    ) {\n        //note: allows multiple 'equivalent' edges (to/from same source/target)\n        //console.debug( 'createEdge:', source, target, directed );\n        var isReflexive = sourceName === targetName;\n        if (!this.allowReflexiveEdges && isReflexive) {\n            return null;\n        }\n\n        var sourceVertex = this.vertices[sourceName];\n        var targetVertex = this.vertices[targetName];\n        //note: silently ignores edges from/to unknown vertices\n        if (!(sourceVertex && targetVertex)) {\n            return null;\n        }\n\n        //TODO: prob. move to vertex\n        var self = this,\n            edge = new Edge(sourceName, targetName, data);\n        sourceVertex.edges[targetName] = edge;\n        sourceVertex.degree += 1;\n        self.numEdges += 1;\n\n        //TODO:! don't like having duplicate edges for non-directed graphs\n        // mirror edges (reversing source and target) in non-directed graphs\n        //  but only if not reflexive\n        if (!isReflexive && !directed) {\n            // flip directed to prevent recursion loop\n            self.createEdge(targetName, sourceName, true);\n        }\n\n        return edge;\n    };\n\n    /** Walk over all the edges of the graph using the vertex.eachEdge iterator */\n    Graph.prototype.edges = function(propsOrFn) {\n        return Array.prototype.concat.apply(\n            [],\n            this.eachVertex(function(vertex) {\n                return vertex.eachEdge(propsOrFn);\n            })\n        );\n    };\n\n    /** Iterate over all the vertices in the graph */\n    Graph.prototype.eachVertex = function(propsOrFn) {\n        return iterate(this.vertices, propsOrFn);\n    };\n\n    /** Return a list of the vertices adjacent to vertex */\n    Graph.prototype.adjacent = function(vertex) {\n        var self = this;\n        return iterate(vertex.edges, function(edge) {\n            return self.vertices[edge.target];\n        });\n    };\n\n    /** Call fn on each vertex adjacent to vertex */\n    Graph.prototype.eachAdjacent = function(vertex, fn) {\n        var self = this;\n        return iterate(vertex.edges, function(edge) {\n            var adj = self.vertices[edge.target];\n            return fn.call(vertex, adj, edge);\n        });\n    };\n\n    /** Print the graph to the console (debugging) */\n    Graph.prototype.print = function() {\n        var self = this;\n        console.log(\n            \"Graph has \" + Object.keys(self.vertices).length + \" vertices\"\n        );\n        self.eachVertex(function(vertex) {\n            console.log(vertex.toString());\n            vertex.eachEdge(function(edge) {\n                console.log(\"\\t \" + edge);\n            });\n        });\n        return self;\n    };\n\n    /** Return a DOT format string of this graph */\n    Graph.prototype.toDOT = function() {\n        var self = this,\n            strings = [];\n        strings.push(\"graph bler {\");\n        self.edges(function(edge) {\n            strings.push(\"\\t\" + edge.from + \" -- \" + edge.to + \";\");\n        });\n        strings.push(\"}\");\n        return strings.join(\"\\n\");\n    };\n\n    /** Return vertices and edges of this graph in d3 node/link format */\n    Graph.prototype.toNodesAndLinks = function() {\n        var self = this,\n            indeces = {};\n        return {\n            nodes: self.eachVertex(function(vertex, key, i) {\n                indeces[vertex.name] = i;\n                return vertex.toJSON();\n            }),\n            links: self.edges(function(edge) {\n                var json = edge.toJSON();\n                json.source = indeces[edge.source];\n                json.target = indeces[edge.target];\n                return json;\n            })\n        };\n    };\n\n    /** Return vertices and edges of this graph where edges use the name/id as source and target */\n    Graph.prototype.toVerticesAndEdges = function() {\n        var self = this;\n        return {\n            vertices: self.eachVertex(function(vertex, key) {\n                return vertex.toJSON();\n            }),\n            edges: self.edges(function(edge) {\n                return edge.toJSON();\n            })\n        };\n    };\n\n    /** Search this graph using BFS */\n    Graph.prototype.breadthFirstSearch = function(start, processFns) {\n        return new BreadthFirstSearch(this).search(start);\n    };\n\n    /** Return a searchtree of this graph using BFS */\n    Graph.prototype.breadthFirstSearchTree = function(start, processFns) {\n        return new BreadthFirstSearch(this).searchTree(start);\n    };\n\n    /** Search this graph using DFS */\n    Graph.prototype.depthFirstSearch = function(start, processFns) {\n        return new DepthFirstSearch(this).search(start);\n    };\n\n    /** Return a searchtree of this graph using DFS */\n    Graph.prototype.depthFirstSearchTree = function(start, processFns) {\n        return new DepthFirstSearch(this).searchTree(start);\n    };\n\n    //Graph.prototype.shortestPath = function( start, end ){\n    //};\n    //\n    //Graph.prototype.articulationVertices = function(){\n    //};\n    //\n    //Graph.prototype.isAcyclic = function(){\n    //};\n    //\n    //Graph.prototype.isBipartite = function(){\n    //};\n\n    /** Return an array of weakly connected (no edges between) sub-graphs in this graph */\n    Graph.prototype.weakComponents = function() {\n        //TODO: alternately, instead of returning graph-like objects:\n        //  - could simply decorate the vertices (vertex.component = componentIndex), or clone the graph and do that\n        var self = this,\n            searchGraph = this,\n            undiscovered,\n            components = [];\n\n        function getComponent(undiscoveredVertex) {\n            //TODO: better interface on dfs (search v. searchTree)\n            var search = new DepthFirstSearch(searchGraph)._search(\n                undiscoveredVertex\n            );\n\n            // remove curr discovered from undiscovered\n            undiscovered = undiscovered.filter(function(name) {\n                return !(name in search.discovered);\n            });\n\n            return {\n                vertices: Object.keys(search.discovered).map(function(\n                    vertexName\n                ) {\n                    return self.vertices[vertexName].toJSON();\n                }),\n                edges: search.edges.map(function(edge) {\n                    // restore any reversed edges\n                    var hasBeenReversed =\n                        self.vertices[edge.target].edges[edge.source] !==\n                        undefined;\n                    if (self.directed && hasBeenReversed) {\n                        var swap = edge.source;\n                        edge.source = edge.target;\n                        edge.target = swap;\n                    }\n                    return edge;\n                })\n            };\n        }\n\n        if (self.directed) {\n            // if directed - convert to undirected for search\n            searchGraph = new Graph(false, self.toNodesAndLinks());\n        }\n        undiscovered = Object.keys(searchGraph.vertices);\n        //console.debug( '(initial) undiscovered:', undiscovered );\n        while (undiscovered.length) {\n            var undiscoveredVertex = searchGraph.vertices[undiscovered.shift()];\n            components.push(getComponent(undiscoveredVertex));\n            //console.debug( 'undiscovered now:', undiscovered );\n        }\n\n        //console.debug( 'components:\\n', JSON.stringify( components, null, '  ' ) );\n        return components;\n    };\n\n    /** Return a single graph containing the weakly connected components in this graph */\n    Graph.prototype.weakComponentGraph = function() {\n        //note: although this can often look like the original graph - edges can be lost\n        var components = this.weakComponents();\n        return new Graph(this.directed, {\n            vertices: components.reduce(function(reduction, curr) {\n                return reduction.concat(curr.vertices);\n            }, []),\n            edges: components.reduce(function(reduction, curr) {\n                return reduction.concat(curr.edges);\n            }, [])\n        });\n    };\n\n    /** Return an array of graphs of the weakly connected components in this graph */\n    Graph.prototype.weakComponentGraphArray = function() {\n        //note: although this can often look like the original graph - edges can be lost\n        var graph = this;\n        return this.weakComponents().map(function(component) {\n            return new Graph(graph.directed, component);\n        });\n    };\n\n    // ============================================================================\n    /** Create a random graph with numVerts vertices and numEdges edges (for testing)\n */\n    function randGraph(directed, numVerts, numEdges) {\n        //console.debug( 'randGraph', directed, numVerts, numEdges );\n        var data = { nodes: [], links: [] };\n        function randRange(range) {\n            return Math.floor(Math.random() * range);\n        }\n        for (var i = 0; i < numVerts; i++) {\n            data.nodes.push({ name: i });\n        }\n        for (i = 0; i < numEdges; i++) {\n            data.links.push({\n                source: randRange(numVerts),\n                target: randRange(numVerts)\n            });\n        }\n        //console.debug( JSON.stringify( data, null, '  ' ) );\n        return new Graph(directed, data);\n    }\n\n    // ============================================================================\n    return {\n        Vertex: Vertex,\n        Edge: Edge,\n        BreadthFirstSearch: BreadthFirstSearch,\n        DepthFirstSearch: DepthFirstSearch,\n        Graph: Graph,\n        randGraph: randGraph\n    };\n});\n"]}