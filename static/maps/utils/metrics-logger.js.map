{"version":3,"sources":["utils/metrics-logger.js"],"names":["define","MetricsLogger","options","self","this","window","bootstrapped","user","id","userId","consoleLogger","_init","LoggingCache","_cache","removed","ALL","LOG","DEBUG","INFO","WARN","ERROR","METRIC","NONE","defaultOptions","logLevel","consoleLevel","defaultNamespace","consoleNamespaceWhitelist","clientPrefix","maxCacheSize","postSize","addTime","cacheKeyPrefix","postUrl","delayPostInMs","getPingData","undefined","onServerResponse","prototype","k","hasOwnProperty","_parseLevel","_waiting","_postSize","_initCache","cache","maxSize","key","_emitToConsole","err","type","level","_typeof","upper","toUpperCase","emit","namespace","logArguments","_addToCache","arguments","length","entry","_buildEntry","Date","_postCache","when","entries","postData","args","metrics","JSON","stringify","_sending","done","jQuery","count","get","_delayPost","setTimeout","whitelist","fail","xhr","status","message","Array","slice","readyState","responseText","info","log","indexOf","call","unshift","apply","error","warn","_hasStorage","debug","empty","overage","push","localStorage","setItem","Error","console","removeItem","e","_initStorage","getItem","add","_fetchAndParse","splice","_unparseAndStore","parse","remove","print"],"mappings":"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","file":"../../scripts/utils/metrics-logger.js","sourcesContent":["define([], function() {\n    /*global window, jQuery, console */\n    /*=============================================================================\nTODO:\n    while anon: logs saved to 'logs-null' - this will never post\n        unless we manually do so at/after login\n        OR prepend when userId and localStorage has 'logs-null'\n    wire up _delayPost and test\n\n=============================================================================*/\n    /** @class MetricsLogger\n *\n *  Object to cache, output, and post log/metric messages to the server.\n *  Meant to be attached to the Galaxy object.\n *\n *  Log from objects by either attaching logger directly:\n *      panel.logger.metric( 'user dataset deletion', panel.user.id, hda.toJSON() )\n *  or using the LoggableMixin or addLogging function:\n *      MyBackboneModel.extend( LoggableMixin ).extend({ ... })\n *      addLogging( MyBackboneModel, 'my-backbone-model' )\n *\n *  Log from templates by calling directly from Galaxy object:\n *      Galaxy.logger.metric( 'template loaded', { ownedByUser : true });\n *\n *  If you attempt to log an un-serializable object (circular reference, window, etc.),\n *  that entry will not be cached (or sent). If you set consoleLevel and consoleLogger\n *  appropriately, a warning will be shown when this happens:\n *      > panel.metric( 'something weird with window', { window : window })\n *      !'Metrics logger could not stringify logArguments: ...'\n */\n    function MetricsLogger(options) {\n        options = options || {};\n        var self = this;\n\n        ///** get the current user's id from bootstrapped data or options */\n        self.userId =\n            window.bootstrapped && window.bootstrapped.user\n                ? window.bootstrapped.user.id\n                : null;\n        self.userId = self.userId || options.userId || null;\n\n        /** the (optional) console to emit logs to */\n        self.consoleLogger = options.consoleLogger || null;\n\n        self._init(options);\n        return self;\n    }\n\n    //----------------------------------------------------------------------------- defaults and constants\n    // see: python std lib, logging\n    MetricsLogger.ALL = 0;\n    MetricsLogger.LOG = 0;\n    MetricsLogger.DEBUG = 10;\n    MetricsLogger.INFO = 20;\n    MetricsLogger.WARN = 30;\n    MetricsLogger.ERROR = 40;\n    // metrics levels here?\n    //MetricsLogger.MinorEvent  = 45;\n    //MetricsLogger.MajorEvent  = 50;\n    MetricsLogger.METRIC = 50;\n    MetricsLogger.NONE = 100;\n\n    /** default options - override these through the constructor */\n    MetricsLogger.defaultOptions = {\n        /** if an incoming message has a level >= this, it will be cached - can also be a string (e.g. 'debug') */\n        logLevel: MetricsLogger.NONE,\n        /** if an incoming message has a level >= this, it will be output to the console */\n        consoleLevel: MetricsLogger.NONE,\n        /** the default 'namespace' or label associated with an incoming message (if none is passed) */\n        defaultNamespace: \"Galaxy\",\n        /** the namespaces output to the console (all namespaces will be output if this is falsy)\n     *  note: applies only to the console (not the event/metrics log/cache)\n     */\n        consoleNamespaceWhitelist: null,\n        /** the prefix attached to client-side logs to distinguish them in the metrics db */\n        clientPrefix: \"client.\",\n\n        /** the maximum number of messages the cache should hold; if exceeded older messages are removed first */\n        maxCacheSize: 3000,\n        /** the number of messages accumulate before posting to the server; should be <= maxCacheSize */\n        postSize: 1000,\n        /** T/F whether to add a timestamp to incoming cached messages */\n        addTime: true,\n        /** string to prefix to userid for cache web storage */\n        cacheKeyPrefix: \"logs-\",\n\n        /** the relative url to post messages to */\n        postUrl: \"/api/metrics\",\n        /** delay before trying post again after two failures */\n        delayPostInMs: 1000 * 60 * 10,\n\n        /** an (optional) function that should return an object; used to send additional data with the metrics */\n        getPingData: undefined,\n        /** an (optional) function that will handle the servers response after successfully posting messages */\n        onServerResponse: undefined\n    };\n\n    //----------------------------------------------------------------------------- set up\n    /** initialize the logger with options, set up instance vars and cache, and add onpageunload to window */\n    MetricsLogger.prototype._init = function _init(options) {\n        var self = this;\n        self.options = {};\n        for (var k in MetricsLogger.defaultOptions) {\n            if (MetricsLogger.defaultOptions.hasOwnProperty(k)) {\n                self.options[k] = options.hasOwnProperty(k)\n                    ? options[k]\n                    : MetricsLogger.defaultOptions[k];\n            }\n        }\n        self.options.logLevel = self._parseLevel(self.options.logLevel);\n        self.options.consoleLevel = self._parseLevel(self.options.consoleLevel);\n        //self._emitToConsole( 'debug', 'MetricsLogger', 'MetricsLogger.options:', self.options );\n\n        /** is the logger currently sending? */\n        self._sending = false;\n        /** the setTimeout id if the logger POST has failed more than once */\n        self._waiting = null;\n        /** the current number of entries to send in a POST */\n        self._postSize = self.options.postSize;\n\n        self._initCache();\n\n        return self;\n    };\n\n    /** initialize the cache */\n    MetricsLogger.prototype._initCache = function _initCache() {\n        try {\n            this.cache = new LoggingCache({\n                maxSize: this.options.maxCacheSize,\n                key: this.options.cacheKeyPrefix + this.userId\n            });\n        } catch (err) {\n            this._emitToConsole(\"warn\", \"MetricsLogger\", [\n                \"Could not intitialize logging cache:\",\n                err\n            ]);\n            this.options.logLevel = MetricsLogger.NONE;\n        }\n    };\n\n    /** return the numeric log level if level in 'none, debug, log, info, warn, error' */\n    MetricsLogger.prototype._parseLevel = function _parseLevel(level) {\n        var type = typeof level;\n        if (type === \"number\") {\n            return level;\n        }\n        if (type === \"string\") {\n            var upper = level.toUpperCase();\n            if (MetricsLogger.hasOwnProperty(upper)) {\n                return MetricsLogger[upper];\n            }\n        }\n        throw new Error(\"Unknown log level: \" + level);\n    };\n\n    //----------------------------------------------------------------------------- main entry point\n    /** record a log/message's arguments to the cache and/or the console based on level and namespace */\n    MetricsLogger.prototype.emit = function emit(\n        level,\n        namespace,\n        logArguments\n    ) {\n        //this._emitToConsole( 'debug', 'MetricsLogger', [ 'emit:', level, namespace, logArguments ]);\n        var self = this;\n        namespace = namespace || self.options.defaultNamespace;\n        if (!level || !logArguments) {\n            return self;\n        }\n        // add to cache if proper level\n        //TODO: respect do not track?\n        //if( !navigator.doNotTrack && level >= self.options.logLevel ){\n        level = self._parseLevel(level);\n        if (level >= self.options.logLevel) {\n            self._addToCache(level, namespace, logArguments);\n        }\n        // also emit to consoleLogger if proper level for that\n        if (self.consoleLogger && level >= self.options.consoleLevel) {\n            self._emitToConsole(level, namespace, logArguments);\n        }\n        return self;\n    };\n\n    //----------------------------------------------------------------------------- cache\n    /** add a message to the cache and if messages.length is high enough post them to the server */\n    MetricsLogger.prototype._addToCache = function _addToCache(\n        level,\n        namespace,\n        logArguments\n    ) {\n        this._emitToConsole(\"debug\", \"MetricsLogger\", [\n            \"_addToCache:\",\n            arguments,\n            this.options.addTime,\n            this.cache.length()\n        ]);\n        //this._emitToConsole( 'debug', 'MetricsLogger', [ '\\t logArguments:', logArguments ]);\n        var self = this;\n        // try add to the cache and if we've got _postSize number of entries, attempt to post them to the server\n        try {\n            var newLength = self.cache.add(\n                self._buildEntry(level, namespace, logArguments)\n            );\n            if (newLength >= self._postSize) {\n                self._postCache();\n            }\n            // discard entry if an error occurs, but warn if level set to do so\n        } catch (err) {\n            self._emitToConsole(\"warn\", \"MetricsLogger\", [\n                \"Metrics logger could not stringify logArguments:\",\n                namespace,\n                logArguments\n            ]);\n            self._emitToConsole(\"error\", \"MetricsLogger\", [err]);\n        }\n        return self;\n    };\n\n    /** build a log cache entry object from the given level, namespace, and arguments (optionally adding timestamp */\n    MetricsLogger.prototype._buildEntry = function _buildEntry(\n        level,\n        namespace,\n        logArguments\n    ) {\n        this._emitToConsole(\"debug\", \"MetricsLogger\", [\n            \"_buildEntry:\",\n            arguments\n        ]);\n        var entry = {\n            level: level,\n            namespace: this.options.clientPrefix + namespace,\n            args: logArguments\n        };\n        if (this.options.addTime) {\n            entry.time = new Date().toISOString();\n        }\n        return entry;\n    };\n\n    /** post _postSize messages from the cache to the server, removing them if successful\n *      if the post fails, wait until maxCacheSize is accumulated instead and try again then\n *      in addition to the messages from the cache ('metrics'), any info from getPingData (if set) will be sent\n *      onServerResponse will be called (if set) with any response from the server\n */\n    MetricsLogger.prototype._postCache = function _postCache(options) {\n        options = options || {};\n        this._emitToConsole(\"info\", \"MetricsLogger\", [\n            \"_postCache\",\n            options,\n            this._postSize\n        ]);\n\n        // short circuit if we're already sending\n        if (!this.options.postUrl || this._sending) {\n            return jQuery.when({});\n        }\n\n        var self = this,\n            postSize = options.count || self._postSize,\n            // do not splice - remove after *successful* post\n            entries = self.cache.get(postSize),\n            entriesLength = entries.length,\n            // use the optional getPingData to add any extra info we may want to send\n            postData =\n                typeof self.options.getPingData === \"function\"\n                    ? self.options.getPingData()\n                    : {};\n        //console.debug( postSize, entriesLength );\n\n        // add the metrics and send\n        postData.metrics = JSON.stringify(entries);\n        //console.debug( postData.metrics );\n        self._sending = true;\n        return jQuery\n            .post(self.options.postUrl, postData)\n            .always(function() {\n                self._sending = false;\n            })\n            .fail(function(xhr, status, message) {\n                // if we failed the previous time, set the next post target to the max num of entries\n                self._postSize = self.options.maxCacheSize;\n                //TODO:??\n                // log this failure to explain any gap in metrics\n                self.emit(\"error\", \"MetricsLogger\", [\n                    \"_postCache error:\",\n                    xhr.readyState,\n                    xhr.status,\n                    xhr.responseJSON || xhr.responseText\n                ]);\n                //TODO: still doesn't solve the problem that when cache == max, post will be tried on every emit\n                //TODO: see _delayPost\n            })\n            .done(function(response) {\n                if (typeof self.options.onServerResponse === \"function\") {\n                    self.options.onServerResponse(response);\n                }\n                // only remove if post successful\n                self.cache.remove(entriesLength);\n                //console.debug( 'removed entries:', entriesLength, 'size now:', self.cache.length() );\n                // if we succeeded, reset the post target to the normal num of entries\n                self._postSize = self.options.postSize;\n            });\n        // return the xhr promise\n    };\n\n    /** set _waiting to true and, after delayPostInMs, set it back to false */\n    MetricsLogger.prototype._delayPost = function _delayPost() {\n        //TODO: this won't work between pages\n        var self = this;\n        self._waiting = setTimeout(function() {\n            self._waiting = null;\n        }, self.options.delayPostInMs);\n    };\n\n    //----------------------------------------------------------------------------- console\n    /** output message to console based on level and consoleLogger type */\n    MetricsLogger.prototype._emitToConsole = function _emitToConsole(\n        level,\n        namespace,\n        logArguments\n    ) {\n        //console.debug( '_emitToConsole:', level, namespace, logArguments );\n        var self = this,\n            whitelist = self.options.consoleNamespaceWhitelist;\n        if (!self.consoleLogger) {\n            return self;\n        }\n        // if a whitelist for namespaces is set, bail if this namespace is not in the list\n        if (whitelist && whitelist.indexOf(namespace) === -1) {\n            return self;\n        }\n\n        var args = Array.prototype.slice.call(logArguments, 0);\n        args.unshift(namespace);\n        //TODO: script location and/or source maps?\n        //TODO: branch on navigator.userAgent == AIIEEE - it only has log\n        if (\n            level >= MetricsLogger.METRIC &&\n            typeof self.consoleLogger.info === \"function\"\n        ) {\n            return self.consoleLogger.info.apply(self.consoleLogger, args);\n        } else if (\n            level >= MetricsLogger.ERROR &&\n            typeof self.consoleLogger.error === \"function\"\n        ) {\n            return self.consoleLogger.error.apply(self.consoleLogger, args);\n        } else if (\n            level >= MetricsLogger.WARN &&\n            typeof self.consoleLogger.warn === \"function\"\n        ) {\n            self.consoleLogger.warn.apply(self.consoleLogger, args);\n        } else if (\n            level >= MetricsLogger.INFO &&\n            typeof self.consoleLogger.info === \"function\"\n        ) {\n            self.consoleLogger.info.apply(self.consoleLogger, args);\n        } else if (\n            level >= MetricsLogger.DEBUG &&\n            typeof self.consoleLogger.debug === \"function\"\n        ) {\n            self.consoleLogger.debug.apply(self.consoleLogger, args);\n        } else if (typeof self.consoleLogger.log === \"function\") {\n            self.consoleLogger.log.apply(self.consoleLogger, args);\n        }\n        return self;\n    };\n\n    //----------------------------------------------------------------------------- shortcuts\n    // generic functions when logging from non-namespaced object (e.g. templates)\n    /** log to default namespace */\n    MetricsLogger.prototype.log = function log() {\n        this.emit(\n            1,\n            this.options.defaultNamespace,\n            Array.prototype.slice.call(arguments, 0)\n        );\n    };\n\n    /** debug to default namespace */\n    MetricsLogger.prototype.debug = function debug() {\n        this.emit(\n            MetricsLogger.DEBUG,\n            this.options.defaultNamespace,\n            Array.prototype.slice.call(arguments, 0)\n        );\n    };\n\n    /** info to default namespace */\n    MetricsLogger.prototype.info = function info() {\n        this.emit(\n            MetricsLogger.INFO,\n            this.options.defaultNamespace,\n            Array.prototype.slice.call(arguments, 0)\n        );\n    };\n\n    /** warn to default namespace */\n    MetricsLogger.prototype.warn = function warn() {\n        this.emit(\n            MetricsLogger.WARN,\n            this.options.defaultNamespace,\n            Array.prototype.slice.call(arguments, 0)\n        );\n    };\n\n    /** error to default namespace */\n    MetricsLogger.prototype.error = function error() {\n        this.emit(\n            MetricsLogger.ERROR,\n            this.options.defaultNamespace,\n            Array.prototype.slice.call(arguments, 0)\n        );\n    };\n\n    /** metric to default namespace */\n    MetricsLogger.prototype.metric = function metric() {\n        this.emit(\n            MetricsLogger.METRIC,\n            this.options.defaultNamespace,\n            Array.prototype.slice.call(arguments, 0)\n        );\n    };\n\n    /* ============================================================================\nTODO:\n    need a performance pass - the JSON un/parsing is a bit much\n\n============================================================================ */\n    /** @class LoggingCache\n *  Simple implementation of cache wrapping an array.\n *\n *  Formats an entry before it's cached and only keeps options.maxSize number\n *  of entries. Older entries are deleted first.\n */\n    function LoggingCache(options) {\n        var self = this;\n        return self._init(options || {});\n    }\n\n    /** default options */\n    LoggingCache.defaultOptions = {\n        /** maximum number of entries to keep before discarding oldest */\n        maxSize: 5000\n    };\n\n    /** initialize with options */\n    LoggingCache.prototype._init = function _init(options) {\n        if (!this._hasStorage()) {\n            //TODO: fall back to jstorage\n            throw new Error(\"LoggingCache needs localStorage\");\n        }\n        if (!options.key) {\n            throw new Error(\"LoggingCache needs key for localStorage\");\n        }\n        this.key = options.key;\n        this._initStorage();\n\n        this.maxSize = options.maxSize || LoggingCache.defaultOptions.maxSize;\n        return this;\n    };\n\n    /** tests for localStorage fns */\n    LoggingCache.prototype._hasStorage = function _hasStorage() {\n        //TODO: modernizr\n        var test = \"test\";\n        try {\n            localStorage.setItem(test, test);\n            localStorage.removeItem(test);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    /** if no localStorage set for key, initialize to empty array */\n    LoggingCache.prototype._initStorage = function _initStorage() {\n        if (localStorage.getItem(this.key) === null) {\n            return this.empty();\n        }\n        return this;\n    };\n\n    /** add an entry to the cache, removing the oldest beforehand if size >= maxSize */\n    LoggingCache.prototype.add = function add(entry) {\n        var self = this,\n            _cache = self._fetchAndParse(),\n            overage = _cache.length + 1 - self.maxSize;\n        if (overage > 0) {\n            _cache.splice(0, overage);\n        }\n        _cache.push(entry);\n        self._unparseAndStore(_cache);\n        return _cache.length;\n    };\n\n    /** get the entries from localStorage and parse them */\n    LoggingCache.prototype._fetchAndParse = function _fetchAndParse() {\n        var self = this;\n        return JSON.parse(localStorage.getItem(self.key));\n    };\n\n    /** stringify the entries and put them in localStorage */\n    LoggingCache.prototype._unparseAndStore = function _unparseAndStore(\n        entries\n    ) {\n        var self = this;\n        return localStorage.setItem(self.key, JSON.stringify(entries));\n    };\n\n    ///** process the entry before caching */\n    //LoggingCache.prototype._preprocessEntry = function _preprocessEntry( entry ){\n    //    return JSON.stringify( entry );\n    //};\n\n    /** return the length --- oh, getters where are you? */\n    LoggingCache.prototype.length = function length() {\n        return this._fetchAndParse().length;\n    };\n\n    /** get count number of entries starting with the oldest */\n    LoggingCache.prototype.get = function get(count) {\n        return this._fetchAndParse().slice(0, count);\n    };\n\n    /** remove count number of entries starting with the oldest */\n    LoggingCache.prototype.remove = function remove(count) {\n        var _cache = this._fetchAndParse(),\n            removed = _cache.splice(0, count);\n        this._unparseAndStore(_cache);\n        return removed;\n    };\n\n    /** empty/clear the entire cache */\n    LoggingCache.prototype.empty = function empty() {\n        localStorage.setItem(this.key, \"[]\");\n        return this;\n    };\n\n    /** stringify count number of entries (but do not remove) */\n    LoggingCache.prototype.stringify = function stringify(count) {\n        return JSON.stringify(this.get(count));\n    };\n\n    /** outputs entire cache to console */\n    LoggingCache.prototype.print = function print() {\n        // popup? (really, carl? a popup?) - easier to copy/paste\n        console.log(JSON.stringify(this._fetchAndParse(), null, \"  \"));\n    };\n\n    //=============================================================================\n    return {\n        MetricsLogger: MetricsLogger,\n        LoggingCache: LoggingCache\n    };\n});\n"]}