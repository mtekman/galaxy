{"version":3,"sources":["viz/trackster/painters.js"],"names":["define","_","CONTAINED_BY","first_region","second_region","AFTER","compute_overlap","first_start","first_end","second_end","overlap","second_start","OVERLAP_END","OVERLAP_START","is_overlap","dashedLine","ctx","x1","y1","x2","y2","dashLen","undefined","dashX","dY","dX","floor","Math","sqrt","dashes","q","dashY","fillRect","drawDownwardEquilateralTriangle","down_vertex_y","side_len","down_vertex_x","beginPath","lineTo","y","strokeStyle","fillStyle","fill","closePath","this","stroke","Scaler","default_val","prototype","gen_val","input","DrawResults","options","incomplete_features","feature_mapper","Painter","data","view_start","view_end","prefs","mode","extend","default_prefs","draw","width","height","w_scale","get_start_draw_pos","chrom_pos","_chrom_pos_to_draw_pos","get_end_draw_pos","get_draw_pos","LinePainter","offset","min_value","max","overflow_color","call","in_path","max_value","vertical_range","color","height_px","save","y_zero","round","x_scaled","delta_x_pxs","painter_color","map","slice","d","i","ceil","pref_color","block_color","delta_x_px","parseInt","pref_r","length","len","pref_g","top_overflow","bot_overflow","new_r","new_b","saturation","pref_b","new_g","moveTo","overflow_x","FeaturePositionMapper","feature_positions","slot_height","translation","x_start","x_end","y_translation","map_feature_data","feature_data","slot","x","push","feature_dict","get_feature_data","alpha_scaler","height_scaler","FeaturePainter","connector_color","get_top_padding","max_label_length","rows_required","y_scale","get_row_height","x_draw_coords","required_height","feature","feature_start","textAlign","feature_uid","feature_end","slots","SQUISH_TRACK_HEIGHT","PACK_TRACK_HEIGHT","DENSE_FEATURE_HEIGHT","draw_element","SQUISH_FEATURE_HEIGHT","PACK_FEATURE_HEIGHT","CONNECTOR_COLOR","LinkedFeaturePainter","draw_background_connector","draw_individual_connectors","restore","tile_low","tile_high","f_start","draw_end","full_height","thin_height","thick_height","feature_strand","cur_y_start","cur_height","feature_name","y_start","draw_start","f_end","thick_start","thick_end","reverse_strand_color","label_color","block_start","globalAlpha","last_block_start","feature_te","feature_blocks","feature_ts","block_thick_end","min","ref_seq","canvas","manager","get_pattern","show_insertions","k","k_len","parsed_cigar","op_len","op_char","cigar_ops","block","blocks","cur_block","indexOf","block_end","update_seq_offset","cig_len","block_thick_start","sequence_coord","tile_region","pack_mode","cigar","drawing_blocks","get_draw_coord","draw_connector","last_block_end","seq_offset","hscale_factor","new_height","ws_height","s_end","cur_seq","measureText","fillText","c_start","base_offset","ReadPainter","paint_utils","base_color_fn","draw_last","type","_parse_cigar","cigar_str","base_pos","op","item","strand","read_seq","draw_read","s_start","gap","connector","char_width_px","detail_block_color","draw_height","rect_y","b2_start","t","longest_feature_length","calculate_longest_feature_length","cig_id","view_range","cig","seq_start","angle1","rgb","cig_op","start_pos","c","show_differences","g","color2","weight","color1","w1","w","draw_deletion","Color","insert_x_coord","seq","start_color","end_value","start_value","x_center","end_color","value","SplitRamp","LinearRamp","middle_color","map_value","DiagonalHeatmapPainter","str_len","e2","s2","update_base_offset","thickness","row_height","font","VariantPainter","Array","alt_len","alt","start","locus_data","sample_gts","allele_counts","draw_x_start","draw_y_start","ReadPainterUtils","feature_height","show_sample_data","draw_summary","summary_height","line_height","b1_end","pos","ref","alt_info","indel_info","j","allele_frac","ArcLinkedFeaturePainter","genotype","variant","draw_details","block2_start","block2_end","block1_end","radius","PI","arc","a","isArray","match","substring","split","alpha","eval","toCSS","concat","join","toString","toHSL","h","s","r","b","l","toARGB","mix","p","w2","value_range","positive_ramp","negative_ramp","Infinity","pos_color","neg_color","s1","e1","invsqrt2","ramp","scale","rotate","px_per_base","delete_details_thickness","divider_height","get_required_height","num_samples","get_indel_info","ref_len","base_px","flatten","snp"],"mappings":"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","file":"../../../scripts/viz/trackster/painters.js","sourcesContent":["define([\"libs/underscore\"], function(_) {\n    /**\n * Compute the type of overlap between two regions. They are assumed to be on the same chrom/contig.\n * The overlap is computed relative to the second region; hence, OVERLAP_START indicates that the first\n * region overlaps the start (but not the end) of the second region.\n * NOTE: Coordinates are assumed to be in BED format: half open (start is closed, end is open).\n */\n    var BEFORE = 1001,\n        CONTAINS = 1002,\n        OVERLAP_START = 1003,\n        OVERLAP_END = 1004,\n        CONTAINED_BY = 1005,\n        AFTER = 1006;\n    var compute_overlap = function(first_region, second_region) {\n        var first_start = first_region[0],\n            first_end = first_region[1],\n            second_start = second_region[0],\n            second_end = second_region[1],\n            overlap;\n        if (first_start < second_start) {\n            if (first_end <= second_start) {\n                overlap = BEFORE;\n            } else if (first_end <= second_end) {\n                overlap = OVERLAP_START;\n            } else {\n                // first_end > second_end\n                overlap = CONTAINS;\n            }\n        } else {\n            // first_start >= second_start\n            if (first_start > second_end) {\n                overlap = AFTER;\n            } else if (first_end <= second_end) {\n                overlap = CONTAINED_BY;\n            } else {\n                overlap = OVERLAP_END;\n            }\n        }\n\n        return overlap;\n    };\n\n    /**\n * Returns true if regions overlap.\n */\n    var is_overlap = function(first_region, second_region) {\n        var overlap = compute_overlap(first_region, second_region);\n        return overlap !== BEFORE && overlap !== AFTER;\n    };\n\n    /**\n * Draw a dashed line on a canvas using filled rectangles. This function is based on:\n * http://vetruvet.blogspot.com/2010/10/drawing-dashed-lines-on-html5-canvas.html\n * However, that approach uses lines, which don't seem to render as well, so use\n * rectangles instead.\n */\n    var dashedLine = function(ctx, x1, y1, x2, y2, dashLen) {\n        if (dashLen === undefined) {\n            dashLen = 4;\n        }\n        var dX = x2 - x1;\n        var dY = y2 - y1;\n        var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n        var dashX = dX / dashes;\n        var dashY = dY / dashes;\n        var q;\n\n        for (q = 0; q < dashes; q++, x1 += dashX, y1 += dashY) {\n            if (q % 2 !== 0) {\n                continue;\n            }\n            ctx.fillRect(x1, y1, dashLen, 1);\n        }\n    };\n\n    /**\n * Draw an isosceles triangle that points down.\n */\n    var drawDownwardEquilateralTriangle = function(\n        ctx,\n        down_vertex_x,\n        down_vertex_y,\n        side_len\n    ) {\n        // Compute other two points of triangle.\n        var x1 = down_vertex_x - side_len / 2,\n            x2 = down_vertex_x + side_len / 2,\n            y = down_vertex_y - Math.sqrt(side_len * 3 / 2);\n\n        // Draw and fill.\n        ctx.beginPath();\n        ctx.moveTo(x1, y);\n        ctx.lineTo(x2, y);\n        ctx.lineTo(down_vertex_x, down_vertex_y);\n        ctx.lineTo(x1, y);\n\n        ctx.strokeStyle = this.fillStyle;\n        ctx.fill();\n        ctx.stroke();\n        ctx.closePath();\n    };\n\n    /**\n * Base class for all scalers. Scalers produce values that are used to change (scale) drawing attributes.\n */\n    var Scaler = function(default_val) {\n        this.default_val = default_val ? default_val : 1;\n    };\n\n    /**\n * Produce a scaling value.\n */\n    Scaler.prototype.gen_val = function(input) {\n        return this.default_val;\n    };\n\n    /**\n * Results from painter.draw()\n */\n    var DrawResults = function(options) {\n        this.incomplete_features = options.incomplete_features;\n        this.feature_mapper = options.feature_mapper;\n    };\n\n    /**\n * Base class for painters\n *\n * -- Mode and prefs are both optional\n */\n    var Painter = function(data, view_start, view_end, prefs, mode) {\n        // Data and data properties\n        this.data = data;\n        // View\n        this.view_start = view_start;\n        this.view_end = view_end;\n        // Drawing prefs\n        this.prefs = _.extend({}, this.default_prefs, prefs);\n        this.mode = mode;\n    };\n\n    Painter.prototype.default_prefs = {};\n\n    /**\n * Draw on the context using a rectangle of width x height using scale w_scale.\n */\n    Painter.prototype.draw = function(ctx, width, height, w_scale) {};\n\n    /**\n * Get starting drawing position, which is offset a half-base left of coordinate.\n */\n    Painter.prototype.get_start_draw_pos = function(chrom_pos, w_scale) {\n        return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, -0.5);\n    };\n\n    /**\n * Get end drawing position, which is offset a half-base right of coordinate.\n */\n    Painter.prototype.get_end_draw_pos = function(chrom_pos, w_scale) {\n        return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0.5);\n    };\n\n    /**\n * Get drawing position.\n */\n    Painter.prototype.get_draw_pos = function(chrom_pos, w_scale) {\n        return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0);\n    };\n\n    /**\n * Convert chromosome position to drawing position.\n */\n    Painter.prototype._chrom_pos_to_draw_pos = function(\n        chrom_pos,\n        w_scale,\n        offset\n    ) {\n        return Math.floor(\n            w_scale * (Math.max(0, chrom_pos - this.view_start) + offset)\n        );\n    };\n\n    var LinePainter = function(data, view_start, view_end, prefs, mode) {\n        Painter.call(this, data, view_start, view_end, prefs, mode);\n    };\n\n    LinePainter.prototype.default_prefs = {\n        min_value: undefined,\n        max_value: undefined,\n        mode: \"Histogram\",\n        color: \"#000\",\n        overflow_color: \"#F66\"\n    };\n\n    LinePainter.prototype.draw = function(ctx, width, height, w_scale) {\n        var in_path = false,\n            min_value = this.prefs.min_value,\n            max_value = this.prefs.max_value,\n            vertical_range = max_value - min_value,\n            height_px = height,\n            view_start = this.view_start,\n            mode = this.mode,\n            data = this.data;\n\n        ctx.save();\n\n        // Pixel position of 0 on the y axis\n        var y_zero = Math.round(height + min_value / vertical_range * height);\n\n        // Horizontal line to denote x-axis\n        if (mode !== \"Intensity\") {\n            ctx.fillStyle = \"#aaa\";\n            ctx.fillRect(0, y_zero, width, 1);\n        }\n\n        ctx.beginPath();\n        var x_scaled, y, delta_x_pxs;\n        if (data.length > 1) {\n            delta_x_pxs = _.map(data.slice(0, -1), function(d, i) {\n                return Math.ceil((data[i + 1][0] - data[i][0]) * w_scale);\n            });\n        } else {\n            delta_x_pxs = [10];\n        }\n\n        // Painter color can be in either block_color (FeatureTrack) or color pref (LineTrack).\n        var painter_color = this.prefs.block_color || this.prefs.color,\n            // Extract RGB from preference color.\n            pref_color = parseInt(painter_color.slice(1), 16),\n            pref_r = (pref_color & 0xff0000) >> 16,\n            pref_g = (pref_color & 0x00ff00) >> 8,\n            pref_b = pref_color & 0x0000ff,\n            top_overflow = false,\n            bot_overflow = false;\n\n        // Paint track.\n        var delta_x_px;\n        for (var i = 0, len = data.length; i < len; i++) {\n            // Reset attributes for next point.\n            ctx.fillStyle = ctx.strokeStyle = painter_color;\n            top_overflow = bot_overflow = false;\n            delta_x_px = delta_x_pxs[i];\n\n            x_scaled = Math.floor((data[i][0] - view_start - 0.5) * w_scale);\n            y = data[i][1];\n\n            // Process Y (scaler) value.\n            if (y === null) {\n                if (in_path && mode === \"Filled\") {\n                    ctx.lineTo(x_scaled, height_px);\n                }\n                in_path = false;\n                continue;\n            }\n\n            // Bound Y value by min, max.\n            if (y < min_value) {\n                bot_overflow = true;\n                y = min_value;\n            } else if (y > max_value) {\n                top_overflow = true;\n                y = max_value;\n            }\n\n            // Draw point.\n            if (mode === \"Histogram\") {\n                // y becomes the bar height in pixels, which is the negated for canvas coords\n                y = Math.round(y / vertical_range * height_px);\n                ctx.fillRect(x_scaled, y_zero, delta_x_px, -y);\n            } else if (mode === \"Intensity\") {\n                var saturation = (y - min_value) / vertical_range,\n                    // Range is [pref_color, 255] where saturation = 0 --> 255 and saturation = 1 --> pref color\n                    new_r = Math.round(\n                        pref_r + (255 - pref_r) * (1 - saturation)\n                    ),\n                    new_g = Math.round(\n                        pref_g + (255 - pref_g) * (1 - saturation)\n                    ),\n                    new_b = Math.round(\n                        pref_b + (255 - pref_b) * (1 - saturation)\n                    );\n                ctx.fillStyle =\n                    \"rgb(\" + new_r + \",\" + new_g + \",\" + new_b + \")\";\n                ctx.fillRect(x_scaled, 0, delta_x_px, height_px);\n            } else {\n                // mode is Coverage/Line or Filled.\n\n                // Scale Y value.\n                y = Math.round(\n                    height_px - (y - min_value) / vertical_range * height_px\n                );\n                if (in_path) {\n                    ctx.lineTo(x_scaled, y);\n                } else {\n                    in_path = true;\n                    if (mode === \"Filled\") {\n                        ctx.moveTo(x_scaled, height_px);\n                        ctx.lineTo(x_scaled, y);\n                    } else {\n                        ctx.moveTo(x_scaled, y);\n                        // Use this approach (note: same as for filled) to draw line from 0 to\n                        // first data point.\n                        //ctx.moveTo(x_scaled, height_px);\n                        //ctx.lineTo(x_scaled, y);\n                    }\n                }\n            }\n\n            // Draw lines at boundaries if overflowing min or max\n            ctx.fillStyle = this.prefs.overflow_color;\n            if (top_overflow || bot_overflow) {\n                var overflow_x;\n                if (mode === \"Histogram\" || mode === \"Intensity\") {\n                    overflow_x = delta_x_px;\n                } else {\n                    // Line and Filled, which are points\n                    x_scaled -= 2; // Move it over to the left so it's centered on the point\n                    overflow_x = 4;\n                }\n                if (top_overflow) {\n                    ctx.fillRect(x_scaled, 0, overflow_x, 3);\n                }\n                if (bot_overflow) {\n                    ctx.fillRect(x_scaled, height_px - 3, overflow_x, 3);\n                }\n            }\n            ctx.fillStyle = painter_color;\n        }\n        if (mode === \"Filled\") {\n            if (in_path) {\n                ctx.lineTo(x_scaled, y_zero);\n                ctx.lineTo(0, y_zero);\n            }\n            ctx.fill();\n        } else {\n            ctx.stroke();\n        }\n\n        ctx.restore();\n    };\n\n    /**\n * Mapper that contains information about feature locations and data.\n */\n    var FeaturePositionMapper = function(slot_height) {\n        this.feature_positions = {};\n        this.slot_height = slot_height;\n        this.translation = 0;\n        this.y_translation = 0;\n    };\n\n    /**\n * Map feature data to a position defined by <slot, x_start, x_end>.\n */\n    FeaturePositionMapper.prototype.map_feature_data = function(\n        feature_data,\n        slot,\n        x_start,\n        x_end\n    ) {\n        if (!this.feature_positions[slot]) {\n            this.feature_positions[slot] = [];\n        }\n        this.feature_positions[slot].push({\n            data: feature_data,\n            x_start: x_start,\n            x_end: x_end\n        });\n    };\n\n    /**\n * Get feature data for position <x, y>\n */\n    FeaturePositionMapper.prototype.get_feature_data = function(x, y) {\n        // Find slot using Y.\n        var slot = Math.floor((y - this.y_translation) / this.slot_height),\n            feature_dict;\n\n        // May not be over a slot due to padding, margin, etc.\n        if (!this.feature_positions[slot]) {\n            return null;\n        }\n\n        // Find feature using X.\n        x += this.translation;\n        for (var i = 0; i < this.feature_positions[slot].length; i++) {\n            feature_dict = this.feature_positions[slot][i];\n            if (x >= feature_dict.x_start && x <= feature_dict.x_end) {\n                return feature_dict.data;\n            }\n        }\n    };\n\n    /**\n * Abstract object for painting feature tracks. Subclasses must implement draw_element() for painting to work.\n * Painter uses a 0-based, half-open coordinate system; start coordinate is closed--included--and the end is open.\n * This coordinate system matches the BED format.\n */\n    var FeaturePainter = function(\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    ) {\n        Painter.call(this, data, view_start, view_end, prefs, mode);\n        this.alpha_scaler = alpha_scaler ? alpha_scaler : new Scaler();\n        this.height_scaler = height_scaler ? height_scaler : new Scaler();\n        this.max_label_length = 200;\n    };\n\n    FeaturePainter.prototype.default_prefs = {\n        block_color: \"#FFF\",\n        connector_color: \"#FFF\"\n    };\n\n    _.extend(FeaturePainter.prototype, {\n        get_required_height: function(rows_required, width) {\n            // y_scale is the height per row\n            var required_height = this.get_row_height(),\n                y_scale = required_height,\n                mode = this.mode;\n            // If using a packing mode, need to multiply by the number of slots used\n            if (mode === \"no_detail\" || mode === \"Squish\" || mode === \"Pack\") {\n                required_height = rows_required * y_scale;\n            }\n            return required_height + this.get_top_padding(width);\n        },\n\n        /** Extra padding before first row of features */\n        get_top_padding: function(width) {\n            return 0;\n        },\n\n        /**\n     * Draw data on ctx using slots and within the rectangle defined by width and height. Returns\n     * a FeaturePositionMapper object with information about where features were drawn.\n     */\n        draw: function(ctx, width, height, w_scale, slots) {\n            var data = this.data,\n                view_start = this.view_start,\n                view_end = this.view_end;\n\n            ctx.save();\n\n            ctx.fillStyle = this.prefs.block_color;\n            ctx.textAlign = \"right\";\n\n            var y_scale = this.get_row_height(),\n                feature_mapper = new FeaturePositionMapper(y_scale),\n                x_draw_coords,\n                incomplete_features = [];\n\n            for (var i = 0, len = data.length; i < len; i++) {\n                var feature = data[i],\n                    feature_uid = feature[0],\n                    feature_start = feature[1],\n                    feature_end = feature[2],\n                    // Slot valid only if features are slotted and this feature is slotted;\n                    // feature may not be due to lack of space.\n                    slot =\n                        slots && slots[feature_uid] !== undefined\n                            ? slots[feature_uid].slot\n                            : null;\n\n                // Draw feature if (a) mode is dense or feature is slotted (as it must be for all non-dense modes) and\n                // (b) there's overlap between the feature and drawing region.\n                if (\n                    (this.mode === \"Dense\" || slot !== null) &&\n                    (feature_start < view_end && feature_end > view_start)\n                ) {\n                    x_draw_coords = this.draw_element(\n                        ctx,\n                        this.mode,\n                        feature,\n                        slot,\n                        view_start,\n                        view_end,\n                        w_scale,\n                        y_scale,\n                        width\n                    );\n                    feature_mapper.map_feature_data(\n                        feature,\n                        slot,\n                        x_draw_coords[0],\n                        x_draw_coords[1]\n                    );\n\n                    // Add to incomplete features if it's not drawn completely in region.\n                    if (feature_start < view_start || feature_end > view_end) {\n                        incomplete_features.push(feature);\n                    }\n                }\n            }\n\n            ctx.restore();\n\n            feature_mapper.y_translation = this.get_top_padding(width);\n            return new DrawResults({\n                incomplete_features: incomplete_features,\n                feature_mapper: feature_mapper\n            });\n        },\n\n        /**\n     * Abstract function for drawing an individual feature.\n     */\n        draw_element: function(\n            ctx,\n            mode,\n            feature,\n            slot,\n            tile_low,\n            tile_high,\n            w_scale,\n            y_scale,\n            width\n        ) {\n            return [0, 0];\n        }\n    });\n\n    // Constants specific to feature tracks moved here (HACKING, these should\n    // basically all be configuration options)\n    var DENSE_TRACK_HEIGHT = 10,\n        NO_DETAIL_TRACK_HEIGHT = 3,\n        SQUISH_TRACK_HEIGHT = 5,\n        PACK_TRACK_HEIGHT = 10,\n        NO_DETAIL_FEATURE_HEIGHT = 1,\n        DENSE_FEATURE_HEIGHT = 9,\n        SQUISH_FEATURE_HEIGHT = 3,\n        PACK_FEATURE_HEIGHT = 9,\n        LABEL_SPACING = 2,\n        CONNECTOR_COLOR = \"#ccc\";\n\n    var LinkedFeaturePainter = function(\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    ) {\n        FeaturePainter.call(\n            this,\n            data,\n            view_start,\n            view_end,\n            prefs,\n            mode,\n            alpha_scaler,\n            height_scaler\n        );\n        // Whether to draw a single connector in the background that spans the entire feature (the intron fishbone)\n        this.draw_background_connector = true;\n        // Whether to call draw_connector for every pair of blocks\n        this.draw_individual_connectors = false;\n    };\n\n    _.extend(LinkedFeaturePainter.prototype, FeaturePainter.prototype, {\n        /**\n     * Height of a single row, depends on mode\n     */\n        get_row_height: function() {\n            var mode = this.mode,\n                height;\n            if (mode === \"Dense\") {\n                height = DENSE_TRACK_HEIGHT;\n            } else if (mode === \"no_detail\") {\n                height = NO_DETAIL_TRACK_HEIGHT;\n            } else if (mode === \"Squish\") {\n                height = SQUISH_TRACK_HEIGHT;\n            } else {\n                // mode === \"Pack\"\n                height = PACK_TRACK_HEIGHT;\n            }\n            return height;\n        },\n\n        /**\n     * Draw a feature. Returns an array with feature's start and end X coordinates.\n     */\n        draw_element: function(\n            ctx,\n            mode,\n            feature,\n            slot,\n            tile_low,\n            tile_high,\n            w_scale,\n            y_scale,\n            width\n        ) {\n            var feature_uid = feature[0],\n                feature_start = feature[1],\n                feature_end = feature[2],\n                feature_name = feature[3],\n                feature_strand = feature[4],\n                // -0.5 to offset region between bases.\n                f_start = Math.floor(\n                    Math.max(0, (feature_start - tile_low - 0.5) * w_scale)\n                ),\n                f_end = Math.ceil(\n                    Math.min(\n                        width,\n                        Math.max(0, (feature_end - tile_low - 0.5) * w_scale)\n                    )\n                ),\n                draw_start = f_start,\n                draw_end = f_end,\n                y_start =\n                    (mode === \"Dense\" ? 0 : 0 + slot) * y_scale +\n                    this.get_top_padding(width),\n                thickness,\n                y_start,\n                thick_start = null,\n                thick_end = null,\n                // TODO: is there any reason why block, label color cannot be set at the Painter level?\n                // For now, assume '.' === '+'\n                block_color =\n                    !feature_strand ||\n                    feature_strand === \"+\" ||\n                    feature_strand === \".\"\n                        ? this.prefs.block_color\n                        : this.prefs.reverse_strand_color,\n                label_color = this.prefs.label_color;\n\n            // Set global alpha.\n            ctx.globalAlpha = this.alpha_scaler.gen_val(feature);\n\n            // In dense mode, put all data in top slot.\n            if (mode === \"Dense\") {\n                slot = 1;\n            }\n\n            if (mode === \"no_detail\") {\n                // No details for feature, so only one way to display.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(\n                    f_start,\n                    y_start + 5,\n                    f_end - f_start,\n                    NO_DETAIL_FEATURE_HEIGHT\n                );\n            } else {\n                // Mode is either Squish or Pack:\n                // Feature details.\n                var feature_ts = feature[5],\n                    feature_te = feature[6],\n                    feature_blocks = feature[7],\n                    // Whether we are drawing full height or squished features\n                    full_height = true;\n\n                if (feature_ts && feature_te) {\n                    thick_start = Math.floor(\n                        Math.max(0, (feature_ts - tile_low) * w_scale)\n                    );\n                    thick_end = Math.ceil(\n                        Math.min(\n                            width,\n                            Math.max(0, (feature_te - tile_low) * w_scale)\n                        )\n                    );\n                }\n\n                // Set vars that depend on mode.\n                var thin_height, thick_height;\n                if (mode === \"Squish\") {\n                    thin_height = 1;\n                    thick_height = SQUISH_FEATURE_HEIGHT;\n                    full_height = false;\n                } else if (mode === \"Dense\") {\n                    thin_height = 5;\n                    thick_height = DENSE_FEATURE_HEIGHT;\n                } else {\n                    // mode === \"Pack\"\n                    thin_height = 5;\n                    thick_height = PACK_FEATURE_HEIGHT;\n                }\n\n                // Draw feature/feature blocks + connectors.\n                if (!feature_blocks) {\n                    // If there are no blocks, treat the feature as one big exon.\n                    ctx.fillStyle = block_color;\n                    ctx.fillRect(\n                        f_start,\n                        y_start + 1,\n                        f_end - f_start,\n                        thick_height\n                    );\n                    // If strand is specified, draw arrows over feature\n                    if (feature_strand && full_height) {\n                        if (feature_strand === \"+\") {\n                            ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                \"right_strand_inv\"\n                            );\n                        } else if (feature_strand === \"-\") {\n                            ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                \"left_strand_inv\"\n                            );\n                        }\n                        ctx.fillRect(\n                            f_start,\n                            y_start + 1,\n                            f_end - f_start,\n                            thick_height\n                        );\n                    }\n                } else {\n                    //\n                    // There are feature blocks and mode is either Squish or Pack.\n                    //\n                    // Approach: (a) draw whole feature as connector/intron and (b) draw blocks as\n                    // needed. This ensures that whole feature, regardless of whether it starts with\n                    // a block, is visible.\n                    //\n\n                    // Compute y axis start position and height\n                    var cur_y_start, cur_height;\n                    if (mode === \"Squish\" || mode === \"Dense\") {\n                        cur_y_start =\n                            y_start + Math.floor(SQUISH_FEATURE_HEIGHT / 2) + 1;\n                        cur_height = 1;\n                    } else {\n                        // mode === \"Pack\"\n                        if (feature_strand) {\n                            cur_y_start = y_start;\n                            cur_height = thick_height;\n                        } else {\n                            cur_y_start += SQUISH_FEATURE_HEIGHT / 2 + 1;\n                            cur_height = 1;\n                        }\n                    }\n\n                    // Draw whole feature as connector/intron.\n                    if (this.draw_background_connector) {\n                        if (mode === \"Squish\" || mode === \"Dense\") {\n                            ctx.fillStyle = CONNECTOR_COLOR;\n                        } else {\n                            // mode === \"Pack\"\n                            if (feature_strand) {\n                                if (feature_strand === \"+\") {\n                                    ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                        \"right_strand\"\n                                    );\n                                } else if (feature_strand === \"-\") {\n                                    ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                        \"left_strand\"\n                                    );\n                                }\n                            } else {\n                                ctx.fillStyle = CONNECTOR_COLOR;\n                            }\n                        }\n                        ctx.fillRect(\n                            f_start,\n                            cur_y_start,\n                            f_end - f_start,\n                            cur_height\n                        );\n                    }\n\n                    // Draw blocks.\n                    var start_and_height;\n                    for (\n                        var k = 0, k_len = feature_blocks.length;\n                        k < k_len;\n                        k++\n                    ) {\n                        var block = feature_blocks[k],\n                            // -0.5 to offset block between bases.\n                            block_start = Math.floor(\n                                Math.max(\n                                    0,\n                                    (block[0] - tile_low - 0.5) * w_scale\n                                )\n                            ),\n                            block_end = Math.ceil(\n                                Math.min(\n                                    width,\n                                    Math.max(\n                                        (block[1] - tile_low - 0.5) * w_scale\n                                    )\n                                )\n                            ),\n                            last_block_start,\n                            last_block_end;\n\n                        // Skip drawing if block not on tile.\n                        if (block_start > block_end) {\n                            continue;\n                        }\n\n                        // Draw thin block.\n                        ctx.fillStyle = block_color;\n                        ctx.fillRect(\n                            block_start,\n                            y_start + (thick_height - thin_height) / 2 + 1,\n                            block_end - block_start,\n                            thin_height\n                        );\n\n                        // If block intersects with thick region, draw block as thick.\n                        // - No thick is sometimes encoded as thick_start == thick_end, so don't draw in that case\n                        if (\n                            thick_start !== undefined &&\n                            feature_te > feature_ts &&\n                            !(\n                                block_start > thick_end ||\n                                block_end < thick_start\n                            )\n                        ) {\n                            var block_thick_start = Math.max(\n                                    block_start,\n                                    thick_start\n                                ),\n                                block_thick_end = Math.min(\n                                    block_end,\n                                    thick_end\n                                );\n                            ctx.fillRect(\n                                block_thick_start,\n                                y_start + 1,\n                                block_thick_end - block_thick_start,\n                                thick_height\n                            );\n                            if (\n                                feature_blocks.length === 1 &&\n                                mode === \"Pack\"\n                            ) {\n                                // Exactly one block means we have no introns, but do have a distinct \"thick\" region,\n                                // draw arrows over it if in pack mode.\n                                if (feature_strand === \"+\") {\n                                    ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                        \"right_strand_inv\"\n                                    );\n                                } else if (feature_strand === \"-\") {\n                                    ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                        \"left_strand_inv\"\n                                    );\n                                }\n                                // If region is wide enough in pixels, pad a bit\n                                if (block_thick_start + 14 < block_thick_end) {\n                                    block_thick_start += 2;\n                                    block_thick_end -= 2;\n                                }\n                                ctx.fillRect(\n                                    block_thick_start,\n                                    y_start + 1,\n                                    block_thick_end - block_thick_start,\n                                    thick_height\n                                );\n                            }\n                        }\n                        // Draw individual connectors if required\n                        if (\n                            this.draw_individual_connectors &&\n                            last_block_start\n                        ) {\n                            this.draw_connector(\n                                ctx,\n                                last_block_start,\n                                last_block_end,\n                                block_start,\n                                block_end,\n                                y_start\n                            );\n                        }\n                        last_block_start = block_start;\n                        last_block_end = block_end;\n                    }\n\n                    // FIXME: Height scaling only works in Pack mode right now.\n                    if (mode === \"Pack\") {\n                        // Reset alpha so height scaling is not impacted by alpha scaling.\n                        ctx.globalAlpha = 1;\n\n                        // Height scaling: draw white lines to reduce height according to height scale factor.\n                        ctx.fillStyle = \"white\"; // TODO: set this to background color.\n                        var hscale_factor = this.height_scaler.gen_val(feature),\n                            // Ceil ensures that min height is >= 1.\n                            new_height = Math.ceil(\n                                thick_height * hscale_factor\n                            ),\n                            ws_height = Math.round(\n                                (thick_height - new_height) / 2\n                            );\n                        if (hscale_factor !== 1) {\n                            ctx.fillRect(\n                                f_start,\n                                cur_y_start + 1,\n                                f_end - f_start,\n                                ws_height\n                            );\n                            ctx.fillRect(\n                                f_start,\n                                cur_y_start + thick_height - ws_height + 1,\n                                f_end - f_start,\n                                ws_height\n                            );\n                        }\n                    }\n                }\n\n                // Reset alpha so that label is not transparent.\n                ctx.globalAlpha = 1;\n\n                // Draw label for Pack mode.\n                if (\n                    feature_name &&\n                    mode === \"Pack\" &&\n                    feature_start > tile_low\n                ) {\n                    ctx.fillStyle = label_color;\n                    // FIXME: assumption here that the entire view starts at 0\n                    if (\n                        tile_low === 0 &&\n                        f_start - ctx.measureText(feature_name).width < 0\n                    ) {\n                        ctx.textAlign = \"left\";\n                        ctx.fillText(\n                            feature_name,\n                            f_end + LABEL_SPACING,\n                            y_start + 8,\n                            this.max_label_length\n                        );\n                        draw_end +=\n                            ctx.measureText(feature_name).width + LABEL_SPACING;\n                    } else {\n                        ctx.textAlign = \"right\";\n                        ctx.fillText(\n                            feature_name,\n                            f_start - LABEL_SPACING,\n                            y_start + 8,\n                            this.max_label_length\n                        );\n                        draw_start -=\n                            ctx.measureText(feature_name).width + LABEL_SPACING;\n                    }\n                    //ctx.fillStyle = block_color;\n                }\n            }\n\n            // Reset global alpha.\n            ctx.globalAlpha = 1;\n\n            return [draw_start, draw_end];\n        }\n    });\n\n    var ReadPainter = function(\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler,\n        ref_seq,\n        base_color_fn\n    ) {\n        FeaturePainter.call(\n            this,\n            data,\n            view_start,\n            view_end,\n            prefs,\n            mode,\n            alpha_scaler,\n            height_scaler\n        );\n        this.ref_seq = ref_seq ? ref_seq.data : null;\n        this.base_color_fn = base_color_fn;\n    };\n\n    _.extend(ReadPainter.prototype, FeaturePainter.prototype, {\n        /**\n     * Returns height based on mode.\n     */\n        get_row_height: function() {\n            var height,\n                mode = this.mode;\n            if (mode === \"Dense\") {\n                height = DENSE_TRACK_HEIGHT;\n            } else if (mode === \"Squish\") {\n                height = SQUISH_TRACK_HEIGHT;\n            } else {\n                // mode === \"Pack\"\n                height = PACK_TRACK_HEIGHT;\n                if (this.prefs.show_insertions) {\n                    height *= 2;\n                }\n            }\n            return height;\n        },\n\n        /**\n     * Parse CIGAR string to get (a) a list of contiguous drawing blocks (MD=X) and\n     * (b) an array of [ op_index, op_len ] pairs where op_index is an index into the\n     * string 'MIDNSHP=X' Return value is a dictionary with two entries, blocks and cigar\n     */\n        _parse_cigar: function(cigar_str) {\n            var cigar_ops = \"MIDNSHP=X\";\n\n            // Parse cigar.\n            var blocks = [[0, 0]],\n                cur_block = blocks[0],\n                base_pos = 0,\n                // Parse cigar operations out and update/create blocks as needed.\n                parsed_cigar = _.map(\n                    cigar_str.match(/[0-9]+[MIDNSHP=X]/g),\n                    function(op) {\n                        // Get operation length, character.\n                        var op_len = parseInt(op.slice(0, -1), 10),\n                            op_char = op.slice(-1);\n\n                        // Update drawing block.\n                        if (op_char === \"N\") {\n                            // At skip, so need to start new block if current block represents\n                            // drawing area.\n                            if (cur_block[1] !== 0) {\n                                cur_block = [\n                                    base_pos + op_len,\n                                    base_pos + op_len\n                                ];\n                                blocks.push(cur_block);\n                            }\n                        } else if (\"ISHP\".indexOf(op_char) === -1) {\n                            // Operation is M,D,=,X.\n                            cur_block[1] += op_len;\n                            base_pos += op_len;\n                        }\n\n                        // Return parsed cigar.\n                        return [cigar_ops.indexOf(op_char), op_len];\n                    }\n                );\n\n            return {\n                blocks: blocks,\n                cigar: parsed_cigar\n            };\n        },\n\n        /**\n     * Draw a single read from reference-based read sequence and cigar.\n     */\n        draw_read: function(\n            ctx,\n            mode,\n            w_scale,\n            y_start,\n            tile_low,\n            tile_high,\n            feature_start,\n            cigar,\n            strand,\n            read_seq\n        ) {\n            // Helper function to update base and sequnence offsets.\n            var update_base_offset = function(offset, cig_op, cig_len) {\n                    if (\"M=NXD\".indexOf(cig_op) !== -1) {\n                        offset += cig_len;\n                    }\n                    return offset;\n                },\n                update_seq_offset = function(offset, cig_op, cig_len) {\n                    if (\"IX\".indexOf(cig_op) !== -1) {\n                        offset += cig_len;\n                    }\n                    return offset;\n                },\n                // Gets drawing coordinate for a sequence coordinate. Assumes closure variables w_scale and tile_low.\n                get_draw_coord = function(sequence_coord) {\n                    // -0.5 to offset sequence between bases.\n                    return Math.floor(\n                        Math.max(0, (sequence_coord - tile_low - 0.5) * w_scale)\n                    );\n                };\n\n            ctx.textAlign = \"center\";\n            var tile_region = [tile_low, tile_high],\n                base_offset = 0,\n                seq_offset = 0,\n                gap = Math.round(w_scale / 2),\n                char_width_px = ctx.canvas.manager.char_width_px,\n                block_color =\n                    strand === \"+\"\n                        ? this.prefs.detail_block_color\n                        : this.prefs.reverse_strand_color,\n                pack_mode = mode === \"Pack\",\n                draw_height = pack_mode\n                    ? PACK_FEATURE_HEIGHT\n                    : SQUISH_FEATURE_HEIGHT,\n                rect_y = y_start + 1,\n                paint_utils = new ReadPainterUtils(\n                    ctx,\n                    draw_height,\n                    w_scale,\n                    mode\n                ),\n                drawing_blocks = [],\n                s_start,\n                s_end;\n\n            // Keep list of items that need to be drawn on top of initial drawing layer.\n            var draw_last = [];\n\n            // Parse cigar and get drawing blocks.\n            var t = this._parse_cigar(cigar);\n            cigar = t.cigar;\n            drawing_blocks = t.blocks;\n\n            // Draw blocks.\n            for (var i = 0; i < drawing_blocks.length; i++) {\n                var block = drawing_blocks[i];\n\n                if (\n                    is_overlap(\n                        [feature_start + block[0], feature_start + block[1]],\n                        tile_region\n                    )\n                ) {\n                    s_start = get_draw_coord(feature_start + block[0]);\n                    s_end = get_draw_coord(feature_start + block[1]);\n\n                    // Make sure that block is drawn even if it too small to be rendered officially; in this case,\n                    // read is drawn at 1px.\n                    // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n                    // and drawing.\n                    if (s_start === s_end) {\n                        s_end += 1;\n                    }\n\n                    // Draw read base as rectangle.\n                    ctx.fillStyle = block_color;\n                    ctx.fillRect(s_start, rect_y, s_end - s_start, draw_height);\n                }\n            }\n\n            // Draw read features.\n            for (var cig_id = 0, len = cigar.length; cig_id < len; cig_id++) {\n                var cig = cigar[cig_id],\n                    cig_op = \"MIDNSHP=X\"[cig[0]],\n                    cig_len = cig[1];\n\n                var seq_start = feature_start + base_offset;\n                s_start = get_draw_coord(seq_start);\n                s_end = get_draw_coord(seq_start + cig_len);\n\n                // Skip feature if it's not in tile.\n                if (\n                    !is_overlap([seq_start, seq_start + cig_len], tile_region)\n                ) {\n                    // Update offsets.\n                    base_offset = update_base_offset(\n                        base_offset,\n                        cig_op,\n                        cig_len\n                    );\n                    seq_offset = update_seq_offset(seq_offset, cig_op, cig_len);\n                    continue;\n                }\n\n                // Make sure that read is drawn even if it too small to be rendered officially; in this case,\n                // read is drawn at 1px.\n                // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n                // and drawing.\n                if (s_start === s_end) {\n                    s_end += 1;\n                }\n\n                // Draw read feature.\n                switch (cig_op) {\n                    case \"H\": // Hard clipping.\n                    case \"S\": // Soft clipping.\n                    case \"P\": // Padding.\n                        // Sequence not present and not related to alignment; do nothing.\n                        break;\n                    case \"M\": // \"Match\".\n                        // Because it's not known whether there is a match, ignore.\n                        base_offset += cig_len;\n                        break;\n                    case \"=\": // Match with reference.\n                    case \"X\": // Mismatch with reference.\n                        //\n                        // Draw sequence and/or variants.\n                        //\n\n                        // Get sequence to draw.\n                        var cur_seq = \"\";\n                        if (cig_op === \"X\") {\n                            // Get sequence from read_seq.\n                            cur_seq = read_seq.slice(\n                                seq_offset,\n                                seq_offset + cig_len\n                            );\n                        } else if (this.ref_seq) {\n                            // && cig_op === '='\n                            // Use reference sequence.\n                            cur_seq = this.ref_seq.slice(\n                                // If read starts after tile start, slice at read start.\n                                Math.max(0, seq_start - tile_low),\n                                // If read ends before tile end, slice at read end.\n                                Math.min(\n                                    seq_start - tile_low + cig_len,\n                                    tile_high - tile_low\n                                )\n                            );\n                        }\n\n                        // Draw sequence. Because cur_seq starts and read/tile start, go to there to start writing.\n                        var start_pos = Math.max(seq_start, tile_low);\n                        for (var c = 0; c < cur_seq.length; c++) {\n                            // Draw base if showing all (i.e. not showing differences) or there is a mismatch.\n                            if (\n                                (cur_seq && !this.prefs.show_differences) ||\n                                cig_op === \"X\"\n                            ) {\n                                // Draw base.\n                                var c_start = Math.floor(\n                                    Math.max(\n                                        0,\n                                        (start_pos + c - tile_low) * w_scale\n                                    )\n                                );\n                                ctx.fillStyle = this.base_color_fn(cur_seq[c]);\n                                if (pack_mode && w_scale > char_width_px) {\n                                    ctx.fillText(\n                                        cur_seq[c],\n                                        c_start,\n                                        y_start + 9\n                                    );\n                                } else if (w_scale > 0.05) {\n                                    // Require a minimum w_scale so that variants are only drawn when somewhat zoomed in.\n                                    ctx.fillRect(\n                                        c_start - gap,\n                                        rect_y,\n                                        Math.max(1, Math.round(w_scale)),\n                                        draw_height\n                                    );\n                                }\n                            }\n                        }\n\n                        // Move forward in sequence only if sequence used to get mismatches.\n                        if (cig_op === \"X\") {\n                            seq_offset += cig_len;\n                        }\n                        base_offset += cig_len;\n\n                        break;\n                    case \"N\": // Skipped bases.\n                        ctx.fillStyle = CONNECTOR_COLOR;\n                        ctx.fillRect(\n                            s_start,\n                            rect_y + (draw_height - 1) / 2,\n                            s_end - s_start,\n                            1\n                        );\n                        // No change in seq_offset because sequence not used when skipping.\n                        base_offset += cig_len;\n                        break;\n                    case \"D\": // Deletion.\n                        paint_utils.draw_deletion(s_start, rect_y, cig_len);\n                        base_offset += cig_len;\n                        break;\n                    case \"I\": // Insertion.\n                        // Check to see if sequence should be drawn at all by looking at the overlap between\n                        // the sequence region and the tile region.\n                        var insert_x_coord = s_start - gap;\n\n                        if (\n                            is_overlap(\n                                [seq_start, seq_start + cig_len],\n                                tile_region\n                            )\n                        ) {\n                            var seq = read_seq.slice(\n                                seq_offset,\n                                seq_offset + cig_len\n                            );\n                            // Insertion point is between the sequence start and the previous base: (-gap) moves\n                            // back from sequence start to insertion point.\n                            if (this.prefs.show_insertions) {\n                                //\n                                // Show inserted sequence above, centered on insertion point.\n                                //\n\n                                // Draw sequence.\n                                // X center is offset + start - <half_sequence_length>\n                                var x_center = s_start - (s_end - s_start) / 2;\n                                if (\n                                    (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                    read_seq !== undefined &&\n                                    w_scale > char_width_px\n                                ) {\n                                    // Draw sequence container.\n                                    ctx.fillStyle = \"yellow\";\n                                    ctx.fillRect(\n                                        x_center - gap,\n                                        y_start - 9,\n                                        s_end - s_start,\n                                        9\n                                    );\n                                    draw_last[draw_last.length] = {\n                                        type: \"triangle\",\n                                        data: [insert_x_coord, y_start + 4, 5]\n                                    };\n                                    ctx.fillStyle = CONNECTOR_COLOR;\n                                    // Based on overlap b/t sequence and tile, get sequence to be drawn.\n                                    switch (compute_overlap(\n                                        [seq_start, seq_start + cig_len],\n                                        tile_region\n                                    )) {\n                                        case OVERLAP_START:\n                                            seq = seq.slice(\n                                                tile_low - seq_start\n                                            );\n                                            break;\n                                        case OVERLAP_END:\n                                            seq = seq.slice(\n                                                0,\n                                                seq_start - tile_high\n                                            );\n                                            break;\n                                        case CONTAINED_BY:\n                                            // All of sequence drawn.\n                                            break;\n                                        case CONTAINS:\n                                            seq = seq.slice(\n                                                tile_low - seq_start,\n                                                seq_start - tile_high\n                                            );\n                                            break;\n                                    }\n                                    // Draw sequence.\n                                    for (\n                                        var c = 0, str_len = seq.length;\n                                        c < str_len;\n                                        c++\n                                    ) {\n                                        var c_start = Math.floor(\n                                            Math.max(\n                                                0,\n                                                (seq_start + c - tile_low) *\n                                                    w_scale\n                                            )\n                                        );\n                                        ctx.fillText(\n                                            seq[c],\n                                            c_start - (s_end - s_start) / 2,\n                                            y_start\n                                        );\n                                    }\n                                } else {\n                                    // Draw block.\n                                    ctx.fillStyle = \"yellow\";\n                                    // TODO: This is a pretty hack-ish way to fill rectangle based on mode.\n                                    ctx.fillRect(\n                                        x_center,\n                                        y_start +\n                                            (this.mode !== \"Dense\" ? 2 : 5),\n                                        s_end - s_start,\n                                        mode !== \"Dense\"\n                                            ? SQUISH_FEATURE_HEIGHT\n                                            : DENSE_FEATURE_HEIGHT\n                                    );\n                                }\n                            } else {\n                                if (\n                                    (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                    read_seq !== undefined &&\n                                    w_scale > char_width_px\n                                ) {\n                                    // Show insertions with a single number at the insertion point.\n                                    draw_last.push({\n                                        type: \"text\",\n                                        data: [\n                                            seq.length,\n                                            insert_x_coord,\n                                            y_start + 9\n                                        ]\n                                    });\n                                } else {\n                                    // TODO: probably can merge this case with code above.\n                                }\n                            }\n                        }\n                        seq_offset += cig_len;\n                        // No change to base offset because insertions are drawn above sequence/read.\n                        break;\n                }\n            }\n\n            //\n            // Draw last items.\n            //\n            ctx.fillStyle = \"yellow\";\n            var item, type, data;\n            for (var i = 0; i < draw_last.length; i++) {\n                item = draw_last[i];\n                type = item.type;\n                data = item.data;\n                if (type === \"text\") {\n                    ctx.save();\n                    ctx.font = \"bold \" + ctx.font;\n                    ctx.fillText(data[0], data[1], data[2]);\n                    ctx.restore();\n                } else if (type === \"triangle\") {\n                    drawDownwardEquilateralTriangle(\n                        ctx,\n                        data[0],\n                        data[1],\n                        data[2]\n                    );\n                }\n            }\n        },\n\n        /**\n     * Draw a complete read pair\n     */\n        draw_element: function(\n            ctx,\n            mode,\n            feature,\n            slot,\n            tile_low,\n            tile_high,\n            w_scale,\n            y_scale,\n            width\n        ) {\n            // All features need a start, end, and vertical center.\n            var feature_uid = feature[0],\n                feature_start = feature[1],\n                feature_end = feature[2],\n                feature_name = feature[3],\n                // -0.5 to put element between bases.\n                f_start = Math.floor(\n                    Math.max(\n                        -0.5 * w_scale,\n                        (feature_start - tile_low - 0.5) * w_scale\n                    )\n                ),\n                f_end = Math.ceil(\n                    Math.min(\n                        width,\n                        Math.max(0, (feature_end - tile_low - 0.5) * w_scale)\n                    )\n                ),\n                y_start = (mode === \"Dense\" ? 0 : 0 + slot) * y_scale,\n                draw_height =\n                    mode === \"Pack\"\n                        ? PACK_FEATURE_HEIGHT\n                        : SQUISH_FEATURE_HEIGHT,\n                label_color = this.prefs.label_color;\n\n            // Draw read.\n            if (feature[5] instanceof Array) {\n                // Read is paired.\n                var connector = true;\n\n                // Draw left/forward read.\n                if (\n                    feature[4][1] >= tile_low &&\n                    feature[4][0] <= tile_high &&\n                    feature[4][2]\n                ) {\n                    this.draw_read(\n                        ctx,\n                        mode,\n                        w_scale,\n                        y_start,\n                        tile_low,\n                        tile_high,\n                        feature[4][0],\n                        feature[4][2],\n                        feature[4][3],\n                        feature[4][4]\n                    );\n                } else {\n                    connector = false;\n                }\n\n                // Draw right/reverse read.\n                if (\n                    feature[5][1] >= tile_low &&\n                    feature[5][0] <= tile_high &&\n                    feature[5][2]\n                ) {\n                    this.draw_read(\n                        ctx,\n                        mode,\n                        w_scale,\n                        y_start,\n                        tile_low,\n                        tile_high,\n                        feature[5][0],\n                        feature[5][2],\n                        feature[5][3],\n                        feature[5][4]\n                    );\n                } else {\n                    connector = false;\n                }\n\n                // Draw connector if both reads were drawn.\n                // TODO: currently, there is no way to connect reads drawn on different tiles; to connect reads on different tiles, data manager\n                // code is needed to join mate pairs from different regions. Alternatively, requesting multiple regions of data at once would\n                // make it possible to put together more easily.\n                // -0.5 to position connector correctly between reads.\n                var b1_end = Math.ceil(\n                        Math.min(\n                            width,\n                            Math.max(\n                                -0.5 * w_scale,\n                                (feature[4][1] - tile_low - 0.5) * w_scale\n                            )\n                        )\n                    ),\n                    b2_start = Math.floor(\n                        Math.max(\n                            -0.5 * w_scale,\n                            (feature[5][0] - tile_low - 0.5) * w_scale\n                        )\n                    );\n                if (connector && b2_start > b1_end) {\n                    ctx.fillStyle = CONNECTOR_COLOR;\n                    var line_height = y_start + 1 + (draw_height - 1) / 2;\n                    dashedLine(ctx, b1_end, line_height, b2_start, line_height);\n                }\n            } else {\n                // Read is single.\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature_start,\n                    feature[4],\n                    feature[5],\n                    feature[6]\n                );\n            }\n            if (\n                mode === \"Pack\" &&\n                feature_start >= tile_low &&\n                feature_name !== \".\"\n            ) {\n                // Draw label.\n                ctx.fillStyle = this.prefs.label_color;\n                if (\n                    tile_low === 0 &&\n                    f_start - ctx.measureText(feature_name).width < 0\n                ) {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(\n                        feature_name,\n                        f_end + LABEL_SPACING,\n                        y_start + 9,\n                        this.max_label_length\n                    );\n                } else {\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(\n                        feature_name,\n                        f_start - LABEL_SPACING,\n                        y_start + 9,\n                        this.max_label_length\n                    );\n                }\n            }\n\n            // FIXME: provide actual coordinates for drawn read.\n            return [0, 0];\n        }\n    });\n\n    var ArcLinkedFeaturePainter = function(\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    ) {\n        LinkedFeaturePainter.call(\n            this,\n            data,\n            view_start,\n            view_end,\n            prefs,\n            mode,\n            alpha_scaler,\n            height_scaler\n        );\n        // Need to know the longest feature length for adding spacing\n        this.longest_feature_length = this.calculate_longest_feature_length();\n        this.draw_background_connector = false;\n        this.draw_individual_connectors = true;\n    };\n\n    _.extend(\n        ArcLinkedFeaturePainter.prototype,\n        FeaturePainter.prototype,\n        LinkedFeaturePainter.prototype,\n        {\n            calculate_longest_feature_length: function() {\n                var longest_feature_length = 0;\n                for (var i = 0, len = this.data.length; i < len; i++) {\n                    var feature = this.data[i],\n                        feature_start = feature[1],\n                        feature_end = feature[2];\n                    longest_feature_length = Math.max(\n                        longest_feature_length,\n                        feature_end - feature_start\n                    );\n                }\n                return longest_feature_length;\n            },\n\n            get_top_padding: function(width) {\n                var view_range = this.view_end - this.view_start,\n                    w_scale = width / view_range;\n                return Math.min(\n                    128,\n                    Math.ceil(this.longest_feature_length / 2 * w_scale)\n                );\n            },\n\n            draw_connector: function(\n                ctx,\n                block1_start,\n                block1_end,\n                block2_start,\n                block2_end,\n                y_start\n            ) {\n                // Arc drawing -- from closest endpoints\n                var x_center = (block1_end + block2_start) / 2,\n                    radius = block2_start - x_center;\n                // For full half circles\n                var angle1 = Math.PI,\n                    angle2 = 0;\n                if (radius > 0) {\n                    ctx.beginPath();\n                    ctx.arc(\n                        x_center,\n                        y_start,\n                        block2_start - x_center,\n                        Math.PI,\n                        0\n                    );\n                    ctx.stroke();\n                }\n            }\n        }\n    );\n\n    // Color stuff from less.js\n\n    var Color = function(rgb, a) {\n        /**\n     * The end goal here, is to parse the arguments\n     * into an integer triplet, such as `128, 255, 0`\n     *\n     * This facilitates operations and conversions.\n     */\n        if (Array.isArray(rgb)) {\n            this.rgb = rgb;\n        } else if (rgb.length == 6) {\n            this.rgb = rgb.match(/.{2}/g).map(function(c) {\n                return parseInt(c, 16);\n            });\n        } else if (rgb.length == 7) {\n            this.rgb = rgb\n                .substring(1, 7)\n                .match(/.{2}/g)\n                .map(function(c) {\n                    return parseInt(c, 16);\n                });\n        } else {\n            this.rgb = rgb.split(\"\").map(function(c) {\n                return parseInt(c + c, 16);\n            });\n        }\n        this.alpha = typeof a === \"number\" ? a : 1;\n    };\n    Color.prototype = {\n        eval: function() {\n            return this;\n        },\n\n        //\n        // If we have some transparency, the only way to represent it\n        // is via `rgba`. Otherwise, we use the hex representation,\n        // which has better compatibility with older browsers.\n        // Values are capped between `0` and `255`, rounded and zero-padded.\n        //\n        toCSS: function() {\n            if (this.alpha < 1.0) {\n                return (\n                    \"rgba(\" +\n                    this.rgb\n                        .map(function(c) {\n                            return Math.round(c);\n                        })\n                        .concat(this.alpha)\n                        .join(\", \") +\n                    \")\"\n                );\n            } else {\n                return (\n                    \"#\" +\n                    this.rgb\n                        .map(function(i) {\n                            i = Math.round(i);\n                            i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                            return i.length === 1 ? \"0\" + i : i;\n                        })\n                        .join(\"\")\n                );\n            }\n        },\n\n        toHSL: function() {\n            var r = this.rgb[0] / 255,\n                g = this.rgb[1] / 255,\n                b = this.rgb[2] / 255,\n                a = this.alpha;\n\n            var max = Math.max(r, g, b),\n                min = Math.min(r, g, b);\n            var h,\n                s,\n                l = (max + min) / 2,\n                d = max - min;\n\n            if (max === min) {\n                h = s = 0;\n            } else {\n                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n                switch (max) {\n                    case r:\n                        h = (g - b) / d + (g < b ? 6 : 0);\n                        break;\n                    case g:\n                        h = (b - r) / d + 2;\n                        break;\n                    case b:\n                        h = (r - g) / d + 4;\n                        break;\n                }\n                h /= 6;\n            }\n            return { h: h * 360, s: s, l: l, a: a };\n        },\n\n        toARGB: function() {\n            var argb = [Math.round(this.alpha * 255)].concat(this.rgb);\n            return (\n                \"#\" +\n                argb\n                    .map(function(i) {\n                        i = Math.round(i);\n                        i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                        return i.length === 1 ? \"0\" + i : i;\n                    })\n                    .join(\"\")\n            );\n        },\n\n        mix: function(color2, weight) {\n            var color1 = this;\n\n            var p = weight; // .value / 100.0;\n            var w = p * 2 - 1;\n            var a = color1.toHSL().a - color2.toHSL().a;\n\n            var w1 = ((w * a == -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n            var w2 = 1 - w1;\n\n            var rgb = [\n                color1.rgb[0] * w1 + color2.rgb[0] * w2,\n                color1.rgb[1] * w1 + color2.rgb[1] * w2,\n                color1.rgb[2] * w1 + color2.rgb[2] * w2\n            ];\n\n            var alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n            return new Color(rgb, alpha);\n        }\n    };\n\n    // End colors from less.js\n\n    var LinearRamp = function(start_color, end_color, start_value, end_value) {\n        /**\n     * Simple linear gradient\n     */\n        this.start_color = new Color(start_color);\n        this.end_color = new Color(end_color);\n        this.start_value = start_value;\n        this.end_value = end_value;\n        this.value_range = end_value - start_value;\n    };\n\n    LinearRamp.prototype.map_value = function(value) {\n        value = Math.max(value, this.start_value);\n        value = Math.min(value, this.end_value);\n        value = (value - this.start_value) / this.value_range;\n        // HACK: just red for now\n        // return \"hsl(0,100%,\" + (value * 100) + \"%)\"\n        return this.start_color.mix(this.end_color, 1 - value).toCSS();\n    };\n\n    var SplitRamp = function(\n        start_color,\n        middle_color,\n        end_color,\n        start_value,\n        end_value\n    ) {\n        /**\n     * Two gradients split away from 0\n     */\n        this.positive_ramp = new LinearRamp(\n            middle_color,\n            end_color,\n            0,\n            end_value\n        );\n        this.negative_ramp = new LinearRamp(\n            middle_color,\n            start_color,\n            0,\n            -start_value\n        );\n        this.start_value = start_value;\n        this.end_value = end_value;\n    };\n\n    SplitRamp.prototype.map_value = function(value) {\n        value = Math.max(value, this.start_value);\n        value = Math.min(value, this.end_value);\n        if (value >= 0) {\n            return this.positive_ramp.map_value(value);\n        } else {\n            return this.negative_ramp.map_value(-value);\n        }\n    };\n\n    var DiagonalHeatmapPainter = function(\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode\n    ) {\n        Painter.call(this, data, view_start, view_end, prefs, mode);\n        var i, len;\n\n        if (this.prefs.min_value === undefined) {\n            var min_value = Infinity;\n            for (i = 0, len = this.data.length; i < len; i++) {\n                min_value = Math.min(min_value, this.data[i][6]);\n            }\n            this.prefs.min_value = min_value;\n        }\n        if (this.prefs.max_value === undefined) {\n            var max_value = -Infinity;\n            for (i = 0, len = this.data.length; i < len; i++) {\n                max_value = Math.max(max_value, this.data[i][6]);\n            }\n            this.prefs.max_value = max_value;\n        }\n    };\n\n    DiagonalHeatmapPainter.prototype.default_prefs = {\n        min_value: undefined,\n        max_value: undefined,\n        mode: \"Heatmap\",\n        pos_color: \"#FF8C00\",\n        neg_color: \"#4169E1\"\n    };\n\n    DiagonalHeatmapPainter.prototype.draw = function(\n        ctx,\n        width,\n        height,\n        w_scale\n    ) {\n        var min_value = this.prefs.min_value,\n            max_value = this.prefs.max_value,\n            value_range = max_value - min_value,\n            height_px = height,\n            view_start = this.view_start,\n            mode = this.mode,\n            data = this.data,\n            invsqrt2 = 1 / Math.sqrt(2);\n\n        var ramp = new SplitRamp(\n            this.prefs.neg_color,\n            \"#FFFFFF\",\n            this.prefs.pos_color,\n            min_value,\n            max_value\n        );\n\n        var d, s1, e1, s2, e2, value;\n\n        var scale = function(p) {\n            return (p - view_start) * w_scale;\n        };\n\n        ctx.save();\n\n        // Draw into triangle, then rotate and scale\n        ctx.rotate(-45 * Math.PI / 180);\n        ctx.scale(invsqrt2, invsqrt2);\n\n        // Paint track.\n        for (var i = 0, len = data.length; i < len; i++) {\n            d = data[i];\n\n            s1 = scale(d[1]);\n            e1 = scale(d[2]);\n            s2 = scale(d[4]);\n            e2 = scale(d[5]);\n            value = d[6];\n\n            ctx.fillStyle = ramp.map_value(value);\n            ctx.fillRect(s1, s2, e1 - s1, e2 - s2);\n        }\n\n        ctx.restore();\n    };\n\n    /**\n * Utilities for painting reads.\n */\n    var ReadPainterUtils = function(ctx, row_height, px_per_base, mode) {\n        this.ctx = ctx;\n        this.row_height = row_height;\n        this.px_per_base = px_per_base;\n        this.draw_details =\n            (mode === \"Pack\" || mode === \"Auto\") &&\n            px_per_base >= ctx.canvas.manager.char_width_px;\n        this.delete_details_thickness = 0.2;\n    };\n\n    _.extend(ReadPainterUtils.prototype, {\n        /**\n     * Draw deletion of base(s).\n     * @param draw_detail if true, drawing in detail and deletion is drawn more subtly\n     */\n        draw_deletion: function(x, y, len) {\n            this.ctx.fillStyle = \"black\";\n            var thickness =\n                (this.draw_details ? this.delete_details_thickness : 1) *\n                this.row_height;\n            y += 0.5 * (this.row_height - thickness);\n            this.ctx.fillRect(x, y, len * this.px_per_base, thickness);\n        }\n    });\n\n    /**\n * Paints variant data onto canvas.\n */\n    var VariantPainter = function(\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        base_color_fn\n    ) {\n        Painter.call(this, data, view_start, view_end, prefs, mode);\n        this.base_color_fn = base_color_fn;\n        this.divider_height = 1;\n    };\n\n    _.extend(VariantPainter.prototype, Painter.prototype, {\n        /**\n     * Height of a single row, depends on mode\n     */\n        get_row_height: function() {\n            var mode = this.mode,\n                height;\n            if (mode === \"Dense\") {\n                height = DENSE_TRACK_HEIGHT;\n            } else if (mode === \"Squish\") {\n                height = SQUISH_TRACK_HEIGHT;\n            } else {\n                // mode === \"Pack\"\n                height = PACK_TRACK_HEIGHT;\n            }\n            return height;\n        },\n\n        /**\n     * Returns required height to draw a particular number of samples in a given mode.\n     */\n        get_required_height: function(num_samples) {\n            // FIXME: for single-sample data, height should be summary_height when zoomed out and\n            // row_height when zoomed in.\n            var height = this.prefs.summary_height;\n\n            // If showing sample data, height is summary + divider + samples.\n            if (num_samples > 1 && this.prefs.show_sample_data) {\n                height +=\n                    this.divider_height + num_samples * this.get_row_height();\n            }\n            return height;\n        },\n\n        /**\n     * Draw on the context using a rectangle of width x height with scale w_scale.\n     */\n        draw: function(ctx, width, height, w_scale) {\n            ctx.save();\n\n            var /**\n         * Returns dictionary of information about an indel; returns empty if there no indel. Assumes indel is left-aligned.\n         * Dict attributes:\n         *    -type: 'insertion' or 'deletion'\n         *    -start: where the deletion starts relative to reference start\n         *    -len: how long the deletion is\n         */\n            get_indel_info = function(ref, alt) {\n                var ref_len = ref.length,\n                    alt_len = alt.length,\n                    start = 0,\n                    len = 1,\n                    type = null;\n                if (alt === \"-\") {\n                    type = \"deletion\";\n                    len = ref.length;\n                } else if (ref.indexOf(alt) === 0 && ref_len > alt_len) {\n                    type = \"deletion\";\n                    len = ref_len - alt_len;\n                    start = alt_len;\n                } else if (alt.indexOf(ref) === 0 && ref_len < alt_len) {\n                    // Insertion.\n                    type = \"insertion\";\n                    len = alt_len - ref_len;\n                    start = alt_len;\n                }\n\n                return type !== null\n                    ? { type: type, start: start, len: len }\n                    : {};\n            };\n\n            // Draw.\n            var locus_data,\n                pos,\n                id,\n                ref,\n                alt,\n                qual,\n                filter,\n                sample_gts,\n                allele_counts,\n                variant,\n                draw_x_start,\n                draw_y_start,\n                genotype,\n                // Always draw variants at least 1 pixel wide.\n                base_px = Math.max(1, Math.floor(w_scale)),\n                // Determine number of samples.\n                num_samples = this.data.length\n                    ? this.data[0][7].split(\",\").length\n                    : 0,\n                row_height =\n                    this.mode === \"Squish\"\n                        ? SQUISH_TRACK_HEIGHT\n                        : PACK_TRACK_HEIGHT,\n                // If zoomed out, fill the whole row with feature to make it easier to read;\n                // when zoomed in, use feature height so that there are gaps in sample rows.\n                feature_height =\n                    w_scale < 0.1\n                        ? row_height\n                        : this.mode === \"Squish\"\n                          ? SQUISH_FEATURE_HEIGHT\n                          : PACK_FEATURE_HEIGHT,\n                draw_summary = true,\n                paint_utils = new ReadPainterUtils(\n                    ctx,\n                    row_height,\n                    w_scale,\n                    this.mode\n                ),\n                j;\n\n            // If there's a single sample, update drawing variables.\n            if (num_samples === 1) {\n                row_height = feature_height =\n                    w_scale < ctx.canvas.manager.char_width_px\n                        ? this.prefs.summary_height\n                        : row_height;\n                paint_utils.row_height = row_height;\n                // No summary when there's a single sample.\n                draw_summary = false;\n            }\n\n            // Draw divider between summary and samples.\n            if (this.prefs.show_sample_data && draw_summary) {\n                ctx.fillStyle = \"#F3F3F3\";\n                ctx.globalAlpha = 1;\n                ctx.fillRect(\n                    0,\n                    this.prefs.summary_height - this.divider_height,\n                    width,\n                    this.divider_height\n                );\n            }\n\n            // Draw variants.\n            ctx.textAlign = \"center\";\n            for (var i = 0; i < this.data.length; i++) {\n                // Get locus data.\n                locus_data = this.data[i];\n                pos = locus_data[1];\n                ref = locus_data[3];\n                alt = [locus_data[4].split(\",\")];\n                sample_gts = locus_data[7].split(\",\");\n                allele_counts = locus_data.slice(8);\n\n                // Process alterate values to derive information about each alt.\n                alt = _.map(_.flatten(alt), function(a) {\n                    var alt_info = {\n                            type: \"snp\",\n                            value: a,\n                            start: 0\n                        },\n                        indel_info = get_indel_info(ref, a);\n\n                    return _.extend(alt_info, indel_info);\n                });\n\n                // Only draw locus data if it's in viewing region.\n                if (pos < this.view_start || pos > this.view_end) {\n                    continue;\n                }\n\n                // Draw summary for alleles.\n                if (draw_summary) {\n                    ctx.fillStyle = \"#999999\";\n                    ctx.globalAlpha = 1;\n                    for (j = 0; j < alt.length; j++) {\n                        // Draw background for summary.\n                        draw_x_start = this.get_start_draw_pos(\n                            pos + alt[j].start,\n                            w_scale\n                        );\n                        ctx.fillRect(\n                            draw_x_start,\n                            0,\n                            base_px,\n                            this.prefs.summary_height\n                        );\n                        draw_y_start = this.prefs.summary_height;\n                        // Draw allele fractions onto summary.\n                        for (j = 0; j < alt.length; j++) {\n                            ctx.fillStyle =\n                                alt[j].type === \"deletion\"\n                                    ? \"black\"\n                                    : this.base_color_fn(alt[j].value);\n                            var allele_frac = allele_counts / sample_gts.length;\n                            var draw_height = Math.ceil(\n                                this.prefs.summary_height * allele_frac\n                            );\n                            ctx.fillRect(\n                                draw_x_start,\n                                draw_y_start - draw_height,\n                                base_px,\n                                draw_height\n                            );\n                            draw_y_start -= draw_height;\n                        }\n                    }\n                }\n\n                // Done drawing if not showing samples data.\n                if (!this.prefs.show_sample_data) {\n                    continue;\n                }\n\n                // Draw sample genotype(s).\n                draw_y_start = draw_summary\n                    ? this.prefs.summary_height + this.divider_height\n                    : 0;\n                for (\n                    j = 0;\n                    j < sample_gts.length;\n                    j++, draw_y_start += row_height\n                ) {\n                    genotype = sample_gts[j]\n                        ? sample_gts[j].split(/\\/|\\|/)\n                        : [\"0\", \"0\"];\n\n                    // Get variant to draw and set drawing properties.\n                    variant = null;\n                    if (genotype[0] === genotype[1]) {\n                        if (genotype[0] === \".\") {\n                            // TODO: draw uncalled variant.\n                        } else if (genotype[0] !== \"0\") {\n                            // Homozygous for variant.\n                            variant = alt[parseInt(genotype[0], 10) - 1];\n                            ctx.globalAlpha = 1;\n                        }\n                        // else reference\n                    } else {\n                        // Heterozygous for variant.\n                        variant =\n                            genotype[0] !== \"0\" ? genotype[0] : genotype[1];\n                        variant = alt[parseInt(variant, 10) - 1];\n                        ctx.globalAlpha = 0.5;\n                    }\n\n                    // If there's a variant, draw it.\n                    if (variant) {\n                        draw_x_start = this.get_start_draw_pos(\n                            pos + variant.start,\n                            w_scale\n                        );\n                        if (variant.type === \"snp\") {\n                            var snp = variant.value;\n                            ctx.fillStyle = this.base_color_fn(snp);\n                            if (paint_utils.draw_details) {\n                                ctx.fillText(\n                                    snp,\n                                    this.get_draw_pos(pos, w_scale),\n                                    draw_y_start + row_height\n                                );\n                            } else {\n                                ctx.fillRect(\n                                    draw_x_start,\n                                    draw_y_start + 1,\n                                    base_px,\n                                    feature_height\n                                );\n                            }\n                        } else if (variant.type === \"deletion\") {\n                            paint_utils.draw_deletion(\n                                draw_x_start,\n                                draw_y_start + 1,\n                                variant.len\n                            );\n                        } else {\n                            // TODO: handle insertions.\n                        }\n                    }\n                }\n            }\n\n            ctx.restore();\n        }\n    });\n\n    return {\n        Scaler: Scaler,\n        LinePainter: LinePainter,\n        LinkedFeaturePainter: LinkedFeaturePainter,\n        ReadPainter: ReadPainter,\n        ArcLinkedFeaturePainter: ArcLinkedFeaturePainter,\n        DiagonalHeatmapPainter: DiagonalHeatmapPainter,\n        VariantPainter: VariantPainter\n    };\n});\n"]}