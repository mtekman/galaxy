{"version":3,"sources":["viz/trackster/slotting.js"],"names":["define","_","SlottedInfo","slot","feature","this","FeatureSlotter","w_scale","mode","max_rows","measureText","slots","start_end_dct","include_label","extend","prototype","_get_draw_coords","Math","floor","draw_end","ceil","draw_start","undefined","f_name","text_len","width","_find_slot","draw_coords","slot_num","has_overlap","s_e","length","k","k_len","slot_features","features","feature_uid","undone","highest_slot","i","len","slotted_info","old_draw_coords","slotted_coords","dc","max","new_draw_coords","push"],"mappings":"aAAAA,QAAQ,mBAAoB,SAASC,GACjC,IASIC,EAAc,SAASC,EAAMC,GAC7BC,KAAKF,KAAOA,EADZD,KAAAA,QAAcE,GAYdE,EAAiB,SAASC,EAASC,EAAMC,EAAUC,GACnDL,KAAKM,SADLL,KAAAA,iBACAD,KAAKM,QAALJ,EACAF,KAAKO,KAAAA,EACLP,KAAKE,cAAL,SAAeA,EACfF,KAAKG,SAALC,EACAJ,KAAKQ,YAALH,GA4LJ,OAnLAI,EAnCab,EAAEa,QAmCRR,EAAeS,WAIlBC,iBAAkB,SAASZ,GAA3BY,IAAAA,EAAkBC,KAAAC,MAAAd,EAAA,GAASA,KAAAA,SACvBe,EAAAF,KAAAG,KAAAhB,EAAA,GAAAC,KAAAE,SACIc,EAAAA,EAAaJ,GAKjB,QAAAK,IAAAC,GAAAlB,KAAAQ,cAAA,CAGI,IAAAW,EACAnB,KAAAK,YAAAa,GAAAE,MAAA,EAIIJ,EAAaG,GAAY,GACzBH,GAAcG,EACD,SAEbL,GAAYK,EACC,SAxBI,OAAAH,EAAAF,IA0DzBO,WAAA,SAAAC,GAII,IAAA,IAFAR,EAAWQ,EADf,GAEAR,EAASS,EAAcA,GACfC,EAAAA,EAAcD,GAAlBvB,KAAAI,SAAAmB,IAAA,CAAA,IACIzB,GAAYS,EACZT,EAAAA,KAASmB,cAAWM,GACpB,QAAAN,IAAAnB,EAEI,IAAA,IAAI2B,EAAAA,EAAM3B,EAAVA,EAAA4B,OAAAC,EAAAC,EAAAD,IAAA,CACA,IAAIb,EAAAA,EAAWW,GACX,GAAAX,EAAAW,EAAA,IAAAT,EAAAS,EAAA,GAAA,CAEAD,GAAA,EACH,OAIL,IAAAA,EACH,OAAAD,EA7EoB,OAAA,GAsFzBM,cAAItB,SAAgBuB,GAUhB/B,IAAAA,IANAgC,EAAAA,EAHAC,EADJhC,KAAAO,cAEI0B,KACAlC,EAHJ,EAUIA,EAAAA,EAAU+B,EAAAA,EAAVJ,OAAAQ,EAAAC,EAAAD,IAAA,CAEAH,GADAA,EAAAA,EAAchC,IACK,GAAnB,IAAIqC,EAAepC,KAAKM,MAAMyB,GAI1B,GAAAK,EAAA,CAMI,GACArC,EAAA,GAAAqC,EAAArC,QAAA,IACAqC,EAAIC,QAAAA,GAAkBtC,EAAKY,GAkB/BsB,IAAAA,IAVQI,EAASC,KAAAA,iBAELC,EAAUF,SAIVC,EAAAA,KAAA3B,iBAAAZ,GACHuC,EAAAtC,KAAAO,cACJ6B,EAAAtC,MAELmC,EAAerB,EAAK4B,EAChBP,EACAP,OAAKpB,IAAMyB,CAEZ,IAAAQ,EAAAD,EAAAX,GAENY,EAAA,KAAAF,EAAA,IACJE,EAAA,KAAAF,EAAA,KAXmBC,EAAeX,GAAKc,GAkBpCV,EAAchC,KAAdyC,IACIlB,EAbItB,KAAKM,MAAMyB,GAAajC,WAG5BkC,EAAOU,KAAKR,GAqBZ3B,IAAAA,IAAAA,EAAAA,EAAAA,EAAcgB,EAAAA,OAAeD,EAAAA,EAAAA,IAA7B,CAKAW,GAJAlC,EAAKO,EAAMyB,EAAXG,KAIetB,GAClB,IAAAU,EAAAtB,KAAAW,iBAAAZ,GAGLwB,EAAAvB,KAAAqB,WAAAC,GAdQC,GAAY,SAEoBN,IAA5BV,EAAcgB,KACdhB,EAAcgB,OAElBhB,EAAcgB,GAAUmB,KAAKpB,GAC7BtB,KAAKM,MAAMyB,GAAe,IAAIlC,EAC1B0B,EACAxB,GAmBfkC,EAAArB,KAAA4B,IAAAP,EAAAV,IADG,OAAOU,EAAe,MAK1BhC,eAAgBA","file":"../../../scripts/viz/trackster/slotting.js","sourcesContent":["define([\"libs/underscore\"], function(_) {\n    var extend = _.extend;\n\n    // HACK: LABEL_SPACING is currently duplicated between here and painters\n    var LABEL_SPACING = 2,\n        PACK_SPACING = 5;\n\n    /**\n * Hold slotting information for a feature.\n */\n    var SlottedInfo = function(slot, feature) {\n        this.slot = slot;\n        this.feature = feature;\n    };\n\n    /**\n * FeatureSlotter determines slots in which to draw features for vertical\n * packing.\n *\n * This implementation is incremental, any feature assigned a slot will be\n * retained for slotting future features.\n */\n    var FeatureSlotter = function(w_scale, mode, max_rows, measureText) {\n        this.slots = {};\n        this.start_end_dct = {};\n        this.w_scale = w_scale;\n        this.mode = mode;\n        this.include_label = mode === \"Pack\";\n        this.max_rows = max_rows;\n        this.measureText = measureText;\n    };\n\n    /**\n * Slot a set of features, `this.slots` will be updated with slots by id, and\n * the largest slot required for the passed set of features is returned\n */\n    extend(FeatureSlotter.prototype, {\n        /**\n     * Get drawing coordinate for a feature.\n     */\n        _get_draw_coords: function(feature) {\n            // Get initial draw coordinates using w_scale.\n            var draw_start = Math.floor(feature[1] * this.w_scale),\n                draw_end = Math.ceil(feature[2] * this.w_scale),\n                f_name = feature[3],\n                text_align;\n\n            // Update start, end drawing locations to include feature name.\n            // Try to put the name on the left, if not, put on right.\n            if (f_name !== undefined && this.include_label) {\n                // Add gap for label spacing and extra pack space padding\n                // TODO: Fix constants\n                var text_len =\n                    this.measureText(f_name).width +\n                    (LABEL_SPACING + PACK_SPACING);\n                if (draw_start - text_len >= 0) {\n                    draw_start -= text_len;\n                    text_align = \"left\";\n                } else {\n                    draw_end += text_len;\n                    text_align = \"right\";\n                }\n            }\n\n            /*\n        if (slot_num < 0) {\n            \n            TODO: this is not yet working --\n            console.log(feature_uid, \"looking for slot with text on the right\");\n            // Slot not found. If text was on left, try on right and see\n            // if slot can be found.\n            // TODO: are there any checks we need to do to ensure that text\n            // will fit on tile?\n            if (text_align === \"left\") {\n                draw_start -= text_len;\n                draw_end -= text_len;\n                text_align = \"right\";\n                slot_num = find_slot(draw_start, draw_end);\n            }\n            if (slot_num >= 0) {\n                console.log(feature_uid, \"found slot with text on the right\");\n            }\n\n        }\n        */\n\n            return [draw_start, draw_end];\n        },\n\n        /**\n     * Find the first slot such that current feature doesn't overlap any other features in that slot.\n     * Returns -1 if no slot was found.\n     */\n        _find_slot: function(draw_coords) {\n            // TODO: Use a data structure for faster searching of available slots.\n            var draw_start = draw_coords[0],\n                draw_end = draw_coords[1];\n            for (var slot_num = 0; slot_num <= this.max_rows; slot_num++) {\n                var has_overlap = false,\n                    slot = this.start_end_dct[slot_num];\n                if (slot !== undefined) {\n                    // Iterate through features already in slot to see if current feature will fit.\n                    for (var k = 0, k_len = slot.length; k < k_len; k++) {\n                        var s_e = slot[k];\n                        if (draw_end > s_e[0] && draw_start < s_e[1]) {\n                            // There is overlap\n                            has_overlap = true;\n                            break;\n                        }\n                    }\n                }\n                if (!has_overlap) {\n                    return slot_num;\n                }\n            }\n            return -1;\n        },\n\n        /**\n     * Slot features.\n     */\n        slot_features: function(features) {\n            var start_end_dct = this.start_end_dct,\n                undone = [],\n                highest_slot = 0,\n                feature,\n                feature_uid;\n\n            // Loop through features to (a) find those that are not yet slotted and (b) update\n            // those that are slotted if new information is availabe. For (a), features already\n            // slotted (based on slotting from other tiles) will retain their current slot.\n            for (var i = 0, len = features.length; i < len; i++) {\n                feature = features[i];\n                feature_uid = feature[0];\n                var slotted_info = this.slots[feature_uid];\n\n                // Separate and handle slotted vs. unslotted features.\n                if (slotted_info) {\n                    // Feature is slotted; if feature now has larger start/end coordinates,\n                    // update drawing coordinates.\n                    if (\n                        feature[1] < slotted_info.feature[1] ||\n                        slotted_info.feature[2] < feature[2]\n                    ) {\n                        // Feature has changed (e.g. a single read now has its pair), so recalculate its\n                        // drawing coordinates.\n                        var old_draw_coords = this._get_draw_coords(\n                                slotted_info.feature\n                            ),\n                            new_draw_coords = this._get_draw_coords(feature),\n                            slotted_coords = this.start_end_dct[\n                                slotted_info.slot\n                            ];\n                        for (var k = 0; k < slotted_coords.length; k++) {\n                            var dc = slotted_coords[k];\n                            if (\n                                dc[0] === old_draw_coords[0] &&\n                                dc[1] === old_draw_coords[1]\n                            ) {\n                                // Replace old drawing coordinates with new ones.\n                                slotted_coords[k] = new_draw_coords;\n                            }\n                        }\n                    }\n                    highest_slot = Math.max(\n                        highest_slot,\n                        this.slots[feature_uid].slot\n                    );\n                } else {\n                    undone.push(i);\n                }\n            }\n\n            // Slot unslotted features.\n\n            // Do slotting.\n            for (var i = 0, len = undone.length; i < len; i++) {\n                feature = features[undone[i]];\n                feature_uid = feature[0];\n                var draw_coords = this._get_draw_coords(feature);\n\n                // Find slot.\n                var slot_num = this._find_slot(draw_coords);\n\n                // Do slotting.\n                if (slot_num >= 0) {\n                    // Add current feature to slot.\n                    if (start_end_dct[slot_num] === undefined) {\n                        start_end_dct[slot_num] = [];\n                    }\n                    start_end_dct[slot_num].push(draw_coords);\n                    this.slots[feature_uid] = new SlottedInfo(\n                        slot_num,\n                        feature\n                    );\n                    highest_slot = Math.max(highest_slot, slot_num);\n                }\n            }\n\n            // Debugging: view slots data.\n            /*\n        for (var i = 0; i < MAX_FEATURE_DEPTH; i++) {\n            var slot = start_end_dct[i];\n            if (slot !== undefined) {\n                console.log(i, \"*************\");\n                for (var k = 0, k_len = slot.length; k < k_len; k++) {\n                    console.log(\"\\t\", slot[k][0], slot[k][1]);\n                }\n            }\n        }\n        */\n            return highest_slot + 1;\n        }\n    });\n\n    return {\n        FeatureSlotter: FeatureSlotter\n    };\n});\n"]}