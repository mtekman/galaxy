{"version":3,"sources":["viz/visualization.js"],"names":["define","CustomToJSON","_","data_mod","util_mod","config_mod","GridView","Tabs","Ui","json","self","this","each","constructor","to_json_keys","k","val","get","to_json_mappers","CanvasManager","dummy_context","image","root","onload","patterns","dummy_canvas","new_canvas","get_pattern","getContext","default_font","measureText","width","load_pattern","Backbone","num_elements","obj_cache","extend","prototype","initialize","key","options","clear","Image","src","Galaxy","path","createPattern","toString","index","$","canvas","key_str","Cache","Model","defaults","key_ary","attributes","get_elt","length","deleted_key","stale","splice","move_key_to_end","set_elt","value","shift","push","GenomeDataManager","data_mode_compatible","size","initial_entries","most_recently_added","entries","entry","set_data","genome","init_data","min_region_size","filters_manager","data_type","mode","dataset","ready_deferred","url","data","call","dataType","add_data","resolve","set","search_features","region","data_is_ready","Deferred","query_type","chrom","ServerStateDeferred","resolution","interval","success_fn","response","when","ss_deferred","i","filters","filter_names","manager","params","hda_ldda","getJSON","load_data","extra_params","low","entry_region","is_subregion","is_deferred","filter_cols","JSON","stringify","result","get_data","last_request","contains","subset_entry","copy","data_manager","new_data_available","new_data_request","cur_data","concat","message","DEEP_DATA_REQ","get_more_detailed_data","get_more_data","req_type","_mark_stale","query_low","start_val","BROAD_DATA_REQ","get_genome_wide_data","max_high","all_data_available","start","end","len","query_region","chrom_data","then","gw_data","max_low","genome_wide_data","console","log","can_get_more_detailed_data","data_point","seq_start","num_samples","detail_multiplier","GenomeReferenceDataManager","chroms_info","get_chroms_info","chrom_info","GenomeRegion","str_val","deferred","parseInt","start_end","subset_fns","bigwig","subregion","filter","refseq","slice","subregion_data","same","dataset_type","compute_overlap","second_chrom","first_start","data_url","second_start","a_region","first_chrom","overlap","overlap_results","Genome","id","dbkey","get_chrom_region","chr_name","find","get_chrom_len","overlaps","DIF_CHROMS","CONTAINS","GenomeRegionCollection","note","from_str","pieces","split","on","default_value","preloaded_data","toJSON","name","color","first_end","second_end","BackboneTrackCollection","Collection","BEFORE","OVERLAP_START","AFTER","CONTAINED_BY","OVERLAP_END","Visualization","chrom_len","ConfigSettingCollection","tracks","view","dummy","obj_type","content_visible","TrackBrowserRouter","model","route","BrowserBookmark","change_location","select_datasets","Dataset","models","label","type","from_models_and_saved_values","prefs","p","d","BackboneTrack","title","urlRoot","save","ajax","vis_json","GenomeVisualization","drawables","bookmarks","viewport","unset","add_tracks","add","Router","new_loc","navigate","go_to","BrowserBookmarkCollection","library_grid","url_base","dict_format","embedded","$el","View","append","history_grid","body","tabs","closing_events","buttons","Add","show","window","requests","track_defs","arguments","current","apply","Array","arg","modal","hide"],"mappings":"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","file":"../../scripts/viz/visualization.js","sourcesContent":["define(\n    [\n        \"libs/underscore\",\n        \"mvc/dataset/data\",\n        \"viz/trackster/util\",\n        \"utils/config\",\n        \"mvc/grid/grid-view\",\n        \"mvc/ui/ui-tabs\",\n        \"mvc/ui/ui-misc\"\n    ],\n    function(_, data_mod, util_mod, config_mod, GridView, Tabs, Ui) {\n        /**\n * Mixin for returning custom JSON representation from toJSON. Class attribute to_json_keys defines a set of attributes\n * to include in the representation; to_json_mappers defines mappers for returned objects.\n */\n        var CustomToJSON = {\n            /**\n     * Returns JSON representation of object using to_json_keys and to_json_mappers.\n     */\n            toJSON: function() {\n                var self = this,\n                    json = {};\n                _.each(self.constructor.to_json_keys, function(k) {\n                    var val = self.get(k);\n                    if (k in self.constructor.to_json_mappers) {\n                        val = self.constructor.to_json_mappers[k](val, self);\n                    }\n                    json[k] = val;\n                });\n                return json;\n            }\n        };\n\n        /**\n * Model, view, and controller objects for Galaxy visualization framework.\n *\n * Models have no references to views, instead using events to indicate state\n * changes; this is advantageous because multiple views can use the same object\n * and models can be used without views.\n */\n\n        /**\n * Use a popup grid to select datasets from histories or libraries. After datasets are selected,\n * track definitions are obtained from the server and the success_fn is called with the list of\n * definitions for selected datasets.\n */\n        var select_datasets = function(filters, success_fn) {\n            // history dataset selection tab\n            var history_grid = new GridView({\n                url_base: Galaxy.root + \"visualization/list_history_datasets\",\n                filters: filters,\n                dict_format: true,\n                embedded: true\n            });\n\n            // library dataset selection tab\n            var library_grid = new GridView({\n                url_base: Galaxy.root + \"visualization/list_library_datasets\",\n                dict_format: true,\n                embedded: true\n            });\n\n            // build tabs\n            var tabs = new Tabs.View();\n            tabs.add({\n                id: \"histories\",\n                title: \"Histories\",\n                $el: $(\"<div/>\").append(history_grid.$el)\n            });\n            tabs.add({\n                id: \"libraries\",\n                title: \"Libraries\",\n                $el: $(\"<div/>\").append(library_grid.$el)\n            });\n\n            // modal\n            Galaxy.modal.show({\n                title: \"Select datasets for new tracks\",\n                body: tabs.$el,\n                closing_events: true,\n                buttons: {\n                    Cancel: function() {\n                        Galaxy.modal.hide();\n                    },\n                    Add: function() {\n                        var requests = [];\n                        tabs\n                            .$(\n                                \"input.grid-row-select-checkbox[name=id]:checked\"\n                            )\n                            .each(function() {\n                                window.console.log($(this).val());\n                                requests[requests.length] = $.ajax({\n                                    url:\n                                        Galaxy.root +\n                                        \"api/datasets/\" +\n                                        $(this).val(),\n                                    dataType: \"json\",\n                                    data: {\n                                        data_type: \"track_config\",\n                                        hda_ldda:\n                                            tabs.current() == \"histories\"\n                                                ? \"hda\"\n                                                : \"ldda\"\n                                    }\n                                });\n                            });\n                        // To preserve order, wait until there are definitions for all tracks and then add\n                        // them sequentially.\n                        $.when.apply($, requests).then(function() {\n                            // jQuery always returns an Array for arguments, so need to look at first element\n                            // to determine whether multiple requests were made and consequently how to\n                            // map arguments to track definitions.\n                            var track_defs =\n                                arguments[0] instanceof Array\n                                    ? $.map(arguments, function(arg) {\n                                          return arg[0];\n                                      })\n                                    : [arguments[0]];\n                            success_fn(track_defs);\n                        });\n                        Galaxy.modal.hide();\n                    }\n                }\n            });\n        };\n\n        // --------- Models ---------\n\n        /**\n * Canvas manager is used to create canvases for browsers as well as providing a pattern cache\n */\n        var CanvasManager = function(default_font) {\n            this.default_font =\n                default_font !== undefined\n                    ? default_font\n                    : \"9px Monaco, Lucida Console, monospace\";\n\n            this.dummy_canvas = this.new_canvas();\n            this.dummy_context = this.dummy_canvas.getContext(\"2d\");\n            this.dummy_context.font = this.default_font;\n\n            this.char_width_px = this.dummy_context.measureText(\"A\").width;\n\n            this.patterns = {};\n\n            // FIXME: move somewhere to make this more general\n            this.load_pattern(\n                \"right_strand\",\n                \"/visualization/strand_right.png\"\n            );\n            this.load_pattern(\"left_strand\", \"/visualization/strand_left.png\");\n            this.load_pattern(\n                \"right_strand_inv\",\n                \"/visualization/strand_right_inv.png\"\n            );\n            this.load_pattern(\n                \"left_strand_inv\",\n                \"/visualization/strand_left_inv.png\"\n            );\n        };\n\n        _.extend(CanvasManager.prototype, {\n            load_pattern: function(key, path) {\n                var patterns = this.patterns,\n                    dummy_context = this.dummy_context,\n                    image = new Image();\n                image.src = Galaxy.root + \"static/images\" + path;\n                image.onload = function() {\n                    patterns[key] = dummy_context.createPattern(\n                        image,\n                        \"repeat\"\n                    );\n                };\n            },\n            get_pattern: function(key) {\n                return this.patterns[key];\n            },\n            new_canvas: function() {\n                var canvas = $(\"<canvas/>\")[0];\n                // Keep a reference back to the manager\n                canvas.manager = this;\n                return canvas;\n            }\n        });\n\n        /**\n * Generic cache that handles key/value pairs. Keys can be any object that can be\n * converted to a String and compared.\n */\n        var Cache = Backbone.Model.extend({\n            defaults: {\n                num_elements: 20,\n                // Objects in cache; indexes into cache are strings of keys.\n                obj_cache: null,\n                // key_ary contains keys for objects in cache.\n                key_ary: null\n            },\n\n            initialize: function(options) {\n                this.clear();\n            },\n\n            /**\n     * Get an element from the cache using its key.\n     */\n            get_elt: function(key) {\n                var obj_cache = this.attributes.obj_cache,\n                    key_ary = this.attributes.key_ary,\n                    key_str = key.toString(),\n                    index = _.indexOf(key_ary, function(k) {\n                        return k.toString() === key_str;\n                    });\n\n                // Update cache.\n                if (index !== -1) {\n                    // Object is in cache, so update it.\n                    if (obj_cache[key_str].stale) {\n                        // Object is stale: remove key and object.\n                        key_ary.splice(index, 1);\n                        delete obj_cache[key_str];\n                    } else {\n                        // Move key to back because it is most recently used.\n                        this.move_key_to_end(key, index);\n                    }\n                }\n\n                return obj_cache[key_str];\n            },\n\n            /**\n     * Put an element into the cache.\n     */\n            set_elt: function(key, value) {\n                var obj_cache = this.attributes.obj_cache,\n                    key_ary = this.attributes.key_ary,\n                    key_str = key.toString(),\n                    num_elements = this.attributes.num_elements;\n\n                // Update keys, objects.\n                if (!obj_cache[key_str]) {\n                    // Add object to cache.\n\n                    if (key_ary.length >= num_elements) {\n                        // Cache full, so remove first element.\n                        var deleted_key = key_ary.shift();\n                        delete obj_cache[deleted_key.toString()];\n                    }\n\n                    // Add key.\n                    key_ary.push(key);\n                }\n\n                // Add object.\n                obj_cache[key_str] = value;\n                return value;\n            },\n\n            /**\n     * Move key to end of cache. Keys are removed from the front, so moving a key to the end\n     * delays the key's removal.\n     */\n            move_key_to_end: function(key, index) {\n                this.attributes.key_ary.splice(index, 1);\n                this.attributes.key_ary.push(key);\n            },\n\n            /**\n     * Clear all elements from the cache.\n     */\n            clear: function() {\n                this.attributes.obj_cache = {};\n                this.attributes.key_ary = [];\n            },\n\n            /** Returns the number of elements in the cache. */\n            size: function() {\n                return this.attributes.key_ary.length;\n            },\n\n            /** Returns key most recently added to cache. */\n            most_recently_added: function() {\n                return this.size() === 0\n                    ? null\n                    : // Most recent key is at the end of key array.\n                      this.attributes.key_ary[\n                          this.attributes.key_ary.length - 1\n                      ];\n            }\n        });\n\n        /**\n * Data manager for genomic data. Data is connected to and queryable by genomic regions.\n */\n        var GenomeDataManager = Cache.extend({\n            defaults: _.extend({}, Cache.prototype.defaults, {\n                dataset: null,\n                genome: null,\n                init_data: null,\n                min_region_size: 200,\n                filters_manager: null,\n                data_type: \"data\",\n                data_mode_compatible: function(entry, mode) {\n                    return true;\n                },\n                can_subset: function(entry) {\n                    return false;\n                }\n            }),\n\n            /**\n     * Initialization.\n     */\n            initialize: function(options) {\n                Cache.prototype.initialize.call(this);\n\n                // Set initial entries in data manager.\n                var initial_entries = this.get(\"init_data\");\n                if (initial_entries) {\n                    this.add_data(initial_entries);\n                }\n            },\n\n            /**\n     * Add data entries to manager; each entry should be a dict with attributes region (key), data, and data_type.\n     * If necessary, manager size is increased to hold all data.\n     */\n            add_data: function(entries) {\n                // Increase size to accomodate all entries.\n                if (this.get(\"num_elements\") < entries.length) {\n                    this.set(\"num_elements\", entries.length);\n                }\n\n                // Put data into manager.\n                var self = this;\n                _.each(entries, function(entry) {\n                    self.set_data(entry.region, entry);\n                });\n            },\n\n            /**\n     * Returns deferred that resolves to true when dataset is ready (or false if dataset\n     * cannot be used).\n     */\n            data_is_ready: function() {\n                var dataset = this.get(\"dataset\"),\n                    ready_deferred = $.Deferred(),\n                    // If requesting raw data, query dataset state; if requesting (converted) data,\n                    // need to query converted datasets state.\n                    query_type =\n                        this.get(\"data_type\") === \"raw_data\"\n                            ? \"state\"\n                            : this.get(\"data_type\") === \"data\"\n                              ? \"converted_datasets_state\"\n                              : \"error\",\n                    ss_deferred = new util_mod.ServerStateDeferred({\n                        ajax_settings: {\n                            url: this.get(\"dataset\").url(),\n                            data: {\n                                hda_ldda: dataset.get(\"hda_ldda\"),\n                                data_type: query_type\n                            },\n                            dataType: \"json\"\n                        },\n                        interval: 5000,\n                        success_fn: function(response) {\n                            return response !== \"pending\";\n                        }\n                    });\n\n                $.when(ss_deferred.go()).then(function(response) {\n                    ready_deferred.resolve(\n                        response === \"ok\" || response === \"data\"\n                    );\n                });\n                return ready_deferred;\n            },\n\n            /**\n     * Perform a feature search from server; returns Deferred object that resolves when data is available.\n     */\n            search_features: function(query) {\n                var dataset = this.get(\"dataset\"),\n                    params = {\n                        query: query,\n                        hda_ldda: dataset.get(\"hda_ldda\"),\n                        data_type: \"features\"\n                    };\n                return $.getJSON(dataset.url(), params);\n            },\n\n            /**\n     * Load data from server and manages data entries. Adds a Deferred to manager\n     * for region; when data becomes available, replaces Deferred with data.\n     * Returns the Deferred that resolves when data is available.\n     */\n            load_data: function(region, mode, resolution, extra_params) {\n                // Setup data request params.\n                var dataset = this.get(\"dataset\"),\n                    params = {\n                        data_type: this.get(\"data_type\"),\n                        chrom: region.get(\"chrom\"),\n                        low: region.get(\"start\"),\n                        high: region.get(\"end\"),\n                        mode: mode,\n                        resolution: resolution,\n                        hda_ldda: dataset.get(\"hda_ldda\")\n                    };\n\n                $.extend(params, extra_params);\n\n                // Add track filters to params.\n                var filters_manager = this.get(\"filters_manager\");\n                if (filters_manager) {\n                    var filter_names = [];\n                    var filters = filters_manager.filters;\n                    for (var i = 0; i < filters.length; i++) {\n                        filter_names.push(filters[i].name);\n                    }\n                    params.filter_cols = JSON.stringify(filter_names);\n                }\n\n                // Do request.\n                var manager = this,\n                    entry = $.getJSON(dataset.url(), params, function(result) {\n                        // Add region to the result.\n                        result.region = region;\n                        manager.set_data(region, result);\n                    });\n\n                this.set_data(region, entry);\n                return entry;\n            },\n\n            /**\n     * Get data from dataset.\n     */\n            get_data: function(region, mode, resolution, extra_params) {\n                // Look for entry and return if it's a deferred or if data available is compatible with mode.\n                var entry = this.get_elt(region);\n                if (\n                    entry &&\n                    (util_mod.is_deferred(entry) ||\n                        this.get(\"data_mode_compatible\")(entry, mode))\n                ) {\n                    return entry;\n                }\n\n                //\n                // Look in cache for data that can be used.\n                // TODO: this logic could be improved if the visualization knew whether\n                // the data was \"index\" or \"data.\"\n                //\n                var key_ary = this.get(\"key_ary\"),\n                    obj_cache = this.get(\"obj_cache\"),\n                    entry_region,\n                    is_subregion;\n                for (var i = 0; i < key_ary.length; i++) {\n                    entry_region = key_ary[i];\n\n                    if (entry_region.contains(region)) {\n                        is_subregion = true;\n\n                        // This entry has data in the requested range. Return if data\n                        // is compatible and can be subsetted.\n                        entry = obj_cache[entry_region.toString()];\n                        if (\n                            util_mod.is_deferred(entry) ||\n                            (this.get(\"data_mode_compatible\")(entry, mode) &&\n                                this.get(\"can_subset\")(entry))\n                        ) {\n                            this.move_key_to_end(entry_region, i);\n\n                            // If there's data, subset it.\n                            if (!util_mod.is_deferred(entry)) {\n                                var subset_entry = this.subset_entry(\n                                    entry,\n                                    region\n                                );\n                                this.set_data(region, subset_entry);\n                                entry = subset_entry;\n                            }\n\n                            return entry;\n                        }\n                    }\n                }\n\n                // FIXME: There _may_ be instances where region is a subregion of another entry but cannot be\n                // subsetted. For these cases, do not increase length because region will never be found (and\n                // an infinite loop will occur.)\n                // If needed, extend region to make it minimum size.\n                if (\n                    !is_subregion &&\n                    region.length() < this.attributes.min_region_size\n                ) {\n                    // IDEA: alternative heuristic is to find adjacent cache entry to region and use that to extend.\n                    // This would prevent bad extensions when zooming in/out while still preserving the behavior\n                    // below.\n\n                    // Use copy of region to avoid changing actual region.\n                    region = region.copy();\n\n                    // Use heuristic to extend region: extend relative to last data request.\n                    var last_request = this.most_recently_added();\n                    if (\n                        !last_request ||\n                        region.get(\"start\") > last_request.get(\"start\")\n                    ) {\n                        // This request is after the last request, so extend right.\n                        region.set(\n                            \"end\",\n                            region.get(\"start\") +\n                                this.attributes.min_region_size\n                        );\n                    } else {\n                        // This request is after the last request, so extend left.\n                        region.set(\n                            \"start\",\n                            region.get(\"end\") - this.attributes.min_region_size\n                        );\n                    }\n\n                    // Trim region to avoid invalid coordinates.\n                    region.set(\"genome\", this.attributes.genome);\n                    region.trim();\n                }\n\n                return this.load_data(region, mode, resolution, extra_params);\n            },\n\n            /**\n     * Alias for set_elt for readbility.\n     */\n            set_data: function(region, entry) {\n                this.set_elt(region, entry);\n            },\n\n            /** \"Deep\" data request; used as a parameter for DataManager.get_more_data() */\n            DEEP_DATA_REQ: \"deep\",\n\n            /** \"Broad\" data request; used as a parameter for DataManager.get_more_data() */\n            BROAD_DATA_REQ: \"breadth\",\n\n            /**\n     * Gets more data for a region using either a depth-first or a breadth-first approach.\n     */\n            get_more_data: function(\n                region,\n                mode,\n                resolution,\n                extra_params,\n                req_type\n            ) {\n                var cur_data = this._mark_stale(region);\n                if (\n                    !(\n                        cur_data &&\n                        this.get(\"data_mode_compatible\")(cur_data, mode)\n                    )\n                ) {\n                    console.log(\n                        \"ERROR: problem with getting more data: current data is not compatible\"\n                    );\n                    return;\n                }\n\n                //\n                // Set parameters based on request type.\n                //\n                var query_low = region.get(\"start\");\n                if (req_type === this.DEEP_DATA_REQ) {\n                    // Use same interval but set start_val to skip data that's already in cur_data.\n                    $.extend(extra_params, {\n                        start_val: cur_data.data.length + 1\n                    });\n                } else if (req_type === this.BROAD_DATA_REQ) {\n                    // To get past an area of extreme feature depth, set query low to be after either\n                    // (a) the maximum high or HACK/FIXME (b) the end of the last feature returned.\n                    query_low =\n                        (cur_data.max_high\n                            ? cur_data.max_high\n                            : cur_data.data[cur_data.data.length - 1][2]) + 1;\n                }\n                var query_region = region.copy().set(\"start\", query_low);\n\n                //\n                // Get additional data, append to current data, and set new data. Use a custom deferred object\n                // to signal when new data is available.\n                //\n                var data_manager = this,\n                    new_data_request = this.load_data(\n                        query_region,\n                        mode,\n                        resolution,\n                        extra_params\n                    ),\n                    new_data_available = $.Deferred();\n                // load_data sets cache to new_data_request, but use custom deferred object so that signal and data\n                // is all data, not just new data.\n                this.set_data(region, new_data_available);\n                $.when(new_data_request).then(function(result) {\n                    // Update data and message.\n                    if (result.data) {\n                        result.data = cur_data.data.concat(result.data);\n                        if (result.max_low) {\n                            result.max_low = cur_data.max_low;\n                        }\n                        if (result.message) {\n                            // HACK: replace number in message with current data length. Works but is ugly.\n                            result.message = result.message.replace(\n                                /[0-9]+/,\n                                result.data.length\n                            );\n                        }\n                    }\n                    data_manager.set_data(region, result);\n                    new_data_available.resolve(result);\n                });\n                return new_data_available;\n            },\n\n            /**\n     * Returns true if more detailed data can be obtained for entry.\n     */\n            can_get_more_detailed_data: function(region) {\n                var cur_data = this.get_elt(region);\n\n                // Can only get more detailed data for bigwig data that has less than 8000 data points.\n                // Summary tree returns *way* too much data, and 8000 data points ~ 500KB.\n                return (\n                    cur_data.dataset_type === \"bigwig\" &&\n                    cur_data.data.length < 8000\n                );\n            },\n\n            /**\n     * Returns more detailed data for an entry.\n     */\n            get_more_detailed_data: function(\n                region,\n                mode,\n                resolution,\n                detail_multiplier,\n                extra_params\n            ) {\n                // Mark current entry as stale.\n                var cur_data = this._mark_stale(region);\n                if (!cur_data) {\n                    console.log(\n                        \"ERROR getting more detailed data: no current data\"\n                    );\n                    return;\n                }\n\n                if (!extra_params) {\n                    extra_params = {};\n                }\n\n                // Use additional parameters to get more detailed data.\n                if (cur_data.dataset_type === \"bigwig\") {\n                    // FIXME: constant should go somewhere.\n                    extra_params.num_samples = 1000 * detail_multiplier;\n                }\n\n                return this.load_data(region, mode, resolution, extra_params);\n            },\n\n            /**\n     * Marks cache data as stale.\n     */\n            _mark_stale: function(region) {\n                var entry = this.get_elt(region);\n                if (!entry) {\n                    console.log(\n                        \"ERROR: no data to mark as stale: \",\n                        this.get(\"dataset\"),\n                        region.toString()\n                    );\n                }\n                entry.stale = true;\n                return entry;\n            },\n\n            /**\n     * Returns an array of data with each entry representing one chromosome/contig\n     * of data or, if data is not available, returns a Deferred that resolves to the\n     * data when it becomes available.\n     */\n            get_genome_wide_data: function(genome) {\n                // -- Get all data. --\n\n                var self = this,\n                    all_data_available = true,\n                    //  Map chromosome info into genome data.\n                    gw_data = _.map(\n                        genome.get(\"chroms_info\").chrom_info,\n                        function(chrom_info) {\n                            var chrom_data = self.get_elt(\n                                new GenomeRegion({\n                                    chrom: chrom_info.chrom,\n                                    start: 0,\n                                    end: chrom_info.len\n                                })\n                            );\n\n                            // Set flag if data is not available.\n                            if (!chrom_data) {\n                                all_data_available = false;\n                            }\n\n                            return chrom_data;\n                        }\n                    );\n\n                // -- If all data is available, return it. --\n                if (all_data_available) {\n                    return gw_data;\n                }\n\n                // -- All data is not available, so load from server. --\n\n                var deferred = $.Deferred();\n                $.getJSON(\n                    this.get(\"dataset\").url(),\n                    { data_type: \"genome_data\" },\n                    function(genome_wide_data) {\n                        self.add_data(genome_wide_data.data);\n                        deferred.resolve(genome_wide_data.data);\n                    }\n                );\n\n                return deferred;\n            },\n\n            /**\n     * Returns entry with only data in the subregion.\n     */\n            subset_entry: function(entry, subregion) {\n                // Dictionary from entry type to function for subsetting data.\n                var subset_fns = {\n                    bigwig: function(data, subregion) {\n                        return _.filter(data, function(data_point) {\n                            return (\n                                data_point[0] >= subregion.get(\"start\") &&\n                                data_point[0] <= subregion.get(\"end\")\n                            );\n                        });\n                    },\n                    refseq: function(data, subregion) {\n                        var seq_start =\n                            subregion.get(\"start\") - entry.region.get(\"start\");\n                        return entry.data.slice(\n                            seq_start,\n                            seq_start + subregion.length()\n                        );\n                    }\n                };\n\n                // Subset entry if there is a function for subsetting and regions are not the same.\n                var subregion_data = entry.data;\n                if (\n                    !entry.region.same(subregion) &&\n                    entry.dataset_type in subset_fns\n                ) {\n                    subregion_data = subset_fns[entry.dataset_type](\n                        entry.data,\n                        subregion\n                    );\n                }\n\n                // Return entry with subregion's data.\n                return {\n                    region: subregion,\n                    data: subregion_data,\n                    dataset_type: entry.dataset_type\n                };\n            }\n        });\n\n        var GenomeReferenceDataManager = GenomeDataManager.extend({\n            initialize: function(options) {\n                // Use generic object in place of dataset and set urlRoot to fetch data.\n                var dataset_placeholder = new Backbone.Model();\n                dataset_placeholder.urlRoot = options.data_url;\n                this.set(\"dataset\", dataset_placeholder);\n            },\n\n            load_data: function(region, mode, resolution, extra_params) {\n                // Fetch data if region is not too large.\n                return region.length() <= 100000\n                    ? GenomeDataManager.prototype.load_data.call(\n                          this,\n                          region,\n                          mode,\n                          resolution,\n                          extra_params\n                      )\n                    : { data: null, region: region };\n            }\n        });\n\n        /**\n * A genome build.\n */\n        var Genome = Backbone.Model.extend({\n            defaults: {\n                name: null,\n                key: null,\n                chroms_info: null\n            },\n\n            initialize: function(options) {\n                this.id = options.dbkey;\n            },\n\n            /**\n     * Shorthand for getting to chromosome information.\n     */\n            get_chroms_info: function() {\n                return this.attributes.chroms_info.chrom_info;\n            },\n\n            /**\n     * Returns a GenomeRegion object denoting a complete chromosome.\n     */\n            get_chrom_region: function(chr_name) {\n                // FIXME: use findWhere in underscore 1.4\n                var chrom_info = _.find(this.get_chroms_info(), function(\n                    chrom_info\n                ) {\n                    return chrom_info.chrom === chr_name;\n                });\n                return new GenomeRegion({\n                    chrom: chrom_info.chrom,\n                    end: chrom_info.len\n                });\n            },\n\n            /** Returns the length of a chromosome. */\n            get_chrom_len: function(chr_name) {\n                // FIXME: use findWhere in underscore 1.4\n                return _.find(this.get_chroms_info(), function(chrom_info) {\n                    return chrom_info.chrom === chr_name;\n                }).len;\n            }\n        });\n\n        /**\n * A genomic region.\n */\n        var GenomeRegion = Backbone.Model.extend(\n            {\n                defaults: {\n                    chrom: null,\n                    start: 0,\n                    end: 0,\n                    str_val: null,\n                    genome: null\n                },\n\n                /**\n     * Returns true if this region is the same as a given region.\n     * It does not test the genome right now.\n     */\n                same: function(region) {\n                    return (\n                        this.attributes.chrom === region.get(\"chrom\") &&\n                        this.attributes.start === region.get(\"start\") &&\n                        this.attributes.end === region.get(\"end\")\n                    );\n                },\n\n                /**\n     * If from_str specified, use it to initialize attributes.\n     */\n                initialize: function(options) {\n                    if (options.from_str) {\n                        var pieces = options.from_str.split(\":\"),\n                            chrom = pieces[0],\n                            start_end = pieces[1].split(\"-\");\n                        this.set({\n                            chrom: chrom,\n                            start: parseInt(start_end[0], 10),\n                            end: parseInt(start_end[1], 10)\n                        });\n                    }\n\n                    // Keep a copy of region's string value for fast lookup.\n                    this.attributes.str_val =\n                        this.get(\"chrom\") +\n                        \":\" +\n                        this.get(\"start\") +\n                        \"-\" +\n                        this.get(\"end\");\n\n                    // Set str_val on attribute change.\n                    this.on(\n                        \"change\",\n                        function() {\n                            this.attributes.str_val =\n                                this.get(\"chrom\") +\n                                \":\" +\n                                this.get(\"start\") +\n                                \"-\" +\n                                this.get(\"end\");\n                        },\n                        this\n                    );\n                },\n\n                copy: function() {\n                    return new GenomeRegion({\n                        chrom: this.get(\"chrom\"),\n                        start: this.get(\"start\"),\n                        end: this.get(\"end\")\n                    });\n                },\n\n                length: function() {\n                    return this.get(\"end\") - this.get(\"start\");\n                },\n\n                /** Returns region in canonical form chrom:start-end */\n                toString: function() {\n                    return this.attributes.str_val;\n                },\n\n                toJSON: function() {\n                    return {\n                        chrom: this.get(\"chrom\"),\n                        start: this.get(\"start\"),\n                        end: this.get(\"end\")\n                    };\n                },\n\n                /**\n     * Compute the type of overlap between this region and another region. The overlap is computed relative to the given/second region;\n     * hence, OVERLAP_START indicates that the first region overlaps the start (but not the end) of the second region.\n     */\n                compute_overlap: function(a_region) {\n                    var first_chrom = this.get(\"chrom\"),\n                        second_chrom = a_region.get(\"chrom\"),\n                        first_start = this.get(\"start\"),\n                        second_start = a_region.get(\"start\"),\n                        first_end = this.get(\"end\"),\n                        second_end = a_region.get(\"end\"),\n                        overlap;\n\n                    // Compare chroms.\n                    if (\n                        first_chrom &&\n                        second_chrom &&\n                        first_chrom !== second_chrom\n                    ) {\n                        return GenomeRegion.overlap_results.DIF_CHROMS;\n                    }\n\n                    // Compare regions.\n                    if (first_start < second_start) {\n                        if (first_end < second_start) {\n                            overlap = GenomeRegion.overlap_results.BEFORE;\n                        } else if (first_end < second_end) {\n                            overlap =\n                                GenomeRegion.overlap_results.OVERLAP_START;\n                        } else {\n                            // first_end >= second_end\n                            overlap = GenomeRegion.overlap_results.CONTAINS;\n                        }\n                    } else if (first_start > second_start) {\n                        if (first_start > second_end) {\n                            overlap = GenomeRegion.overlap_results.AFTER;\n                        } else if (first_end <= second_end) {\n                            overlap = GenomeRegion.overlap_results.CONTAINED_BY;\n                        } else {\n                            overlap = GenomeRegion.overlap_results.OVERLAP_END;\n                        }\n                    } else {\n                        // first_start === second_start\n                        overlap =\n                            first_end >= second_end\n                                ? GenomeRegion.overlap_results.CONTAINS\n                                : GenomeRegion.overlap_results.CONTAINED_BY;\n                    }\n\n                    return overlap;\n                },\n\n                /**\n     * Trim a region to match genome's constraints.\n     */\n                trim: function(genome) {\n                    // Assume that all chromosome/contigs start at 0.\n                    if (this.attributes.start < 0) {\n                        this.attributes.start = 0;\n                    }\n\n                    // Only try to trim the end if genome is set.\n                    if (this.attributes.genome) {\n                        var chrom_len = this.attributes.genome.get_chrom_len(\n                            this.attributes.chrom\n                        );\n                        if (this.attributes.end > chrom_len) {\n                            this.attributes.end = chrom_len - 1;\n                        }\n                    }\n\n                    return this;\n                },\n\n                /**\n     * Returns true if this region contains a given region.\n     */\n                contains: function(a_region) {\n                    return (\n                        this.compute_overlap(a_region) ===\n                        GenomeRegion.overlap_results.CONTAINS\n                    );\n                },\n\n                /**\n     * Returns true if regions overlap.\n     */\n                overlaps: function(a_region) {\n                    return (\n                        _.intersection(\n                            [this.compute_overlap(a_region)],\n                            [\n                                GenomeRegion.overlap_results.DIF_CHROMS,\n                                GenomeRegion.overlap_results.BEFORE,\n                                GenomeRegion.overlap_results.AFTER\n                            ]\n                        ).length === 0\n                    );\n                }\n            },\n            {\n                overlap_results: {\n                    DIF_CHROMS: 1000,\n                    BEFORE: 1001,\n                    CONTAINS: 1002,\n                    OVERLAP_START: 1003,\n                    OVERLAP_END: 1004,\n                    CONTAINED_BY: 1005,\n                    AFTER: 1006\n                }\n            }\n        );\n\n        var GenomeRegionCollection = Backbone.Collection.extend({\n            model: GenomeRegion\n        });\n\n        /**\n * A genome browser bookmark.\n */\n        var BrowserBookmark = Backbone.Model.extend({\n            defaults: {\n                region: null,\n                note: \"\"\n            },\n\n            initialize: function(options) {\n                this.set(\"region\", new GenomeRegion(options.region));\n            }\n        });\n\n        /**\n * Bookmarks collection.\n */\n        var BrowserBookmarkCollection = Backbone.Collection.extend({\n            model: BrowserBookmark\n        });\n\n        /**\n * A track of data in a genome visualization.\n */\n        // TODO: rename to Track and merge with Trackster's Track object.\n        var BackboneTrack = Backbone.Model.extend(CustomToJSON).extend(\n            {\n                defaults: {\n                    mode: \"Auto\"\n                },\n\n                initialize: function(options) {\n                    this.set(\"dataset\", new data_mod.Dataset(options.dataset));\n\n                    // -- Set up config settings. --\n                    var models = [\n                        {\n                            key: \"name\",\n                            default_value: this.get(\"dataset\").get(\"name\")\n                        },\n                        { key: \"color\" },\n                        {\n                            key: \"min_value\",\n                            label: \"Min Value\",\n                            type: \"float\",\n                            default_value: 0\n                        },\n                        {\n                            key: \"max_value\",\n                            label: \"Max Value\",\n                            type: \"float\",\n                            default_value: 1\n                        }\n                    ];\n\n                    this.set(\n                        \"config\",\n                        config_mod.ConfigSettingCollection.from_models_and_saved_values(\n                            models,\n                            options.prefs\n                        )\n                    );\n\n                    // -- Set up data manager. --\n                    var preloaded_data = this.get(\"preloaded_data\");\n                    if (preloaded_data) {\n                        preloaded_data = preloaded_data.data;\n                    } else {\n                        preloaded_data = [];\n                    }\n                    this.set(\n                        \"data_manager\",\n                        new GenomeDataManager({\n                            dataset: this.get(\"dataset\"),\n                            init_data: preloaded_data\n                        })\n                    );\n                }\n            },\n            {\n                // This definition matches that produced by to_dict() methods in tracks.js\n                to_json_keys: [\n                    \"track_type\",\n                    \"dataset\",\n                    \"prefs\",\n                    \"mode\",\n                    \"filters\",\n                    \"tool_state\"\n                ],\n                to_json_mappers: {\n                    prefs: function(p, self) {\n                        if (_.size(p) === 0) {\n                            p = {\n                                name: self\n                                    .get(\"config\")\n                                    .get(\"name\")\n                                    .get(\"value\"),\n                                color: self\n                                    .get(\"config\")\n                                    .get(\"color\")\n                                    .get(\"value\")\n                            };\n                        }\n                        return p;\n                    },\n                    dataset: function(d) {\n                        return {\n                            id: d.id,\n                            hda_ldda: d.get(\"hda_ldda\")\n                        };\n                    }\n                }\n            }\n        );\n\n        var BackboneTrackCollection = Backbone.Collection.extend({\n            model: BackboneTrack\n        });\n\n        /**\n * A visualization.\n */\n        var Visualization = Backbone.Model.extend({\n            defaults: {\n                title: \"\",\n                type: \"\"\n            },\n\n            urlRoot: Galaxy.root + \"api/visualizations\",\n\n            /**\n     * POSTs visualization's JSON to its URL using the parameter 'vis_json'\n     * Note: This is necessary because (a) Galaxy requires keyword args and\n     * (b) Galaxy does not handle PUT now.\n     */\n            save: function() {\n                return $.ajax({\n                    url: this.url(),\n                    type: \"POST\",\n                    dataType: \"json\",\n                    data: {\n                        vis_json: JSON.stringify(this)\n                    }\n                });\n            }\n        });\n\n        /**\n * A visualization of genome data.\n */\n        var GenomeVisualization = Visualization.extend(CustomToJSON).extend(\n            {\n                defaults: _.extend({}, Visualization.prototype.defaults, {\n                    dbkey: \"\",\n                    drawables: null,\n                    bookmarks: null,\n                    viewport: null\n                }),\n\n                initialize: function(options) {\n                    // Replace drawables with tracks.\n                    this.set(\n                        \"drawables\",\n                        new BackboneTrackCollection(options.tracks)\n                    );\n\n                    var models = [];\n                    this.set(\n                        \"config\",\n                        config_mod.ConfigSettingCollection.from_models_and_saved_values(\n                            models,\n                            options.prefs\n                        )\n                    );\n\n                    // Clear track and data definitions to avoid storing large objects.\n                    this.unset(\"tracks\");\n                    this.get(\"drawables\").each(function(d) {\n                        d.unset(\"preloaded_data\");\n                    });\n                },\n\n                /**\n     * Add a track or array of tracks to the visualization.\n     */\n                add_tracks: function(tracks) {\n                    this.get(\"drawables\").add(tracks);\n                }\n            },\n            {\n                // This definition matches that produced by to_dict() methods in tracks.js\n                to_json_keys: [\"view\", \"viewport\", \"bookmarks\"],\n\n                to_json_mappers: {\n                    view: function(dummy, self) {\n                        return {\n                            obj_type: \"View\",\n                            prefs: {\n                                name: self.get(\"title\"),\n                                content_visible: true\n                            },\n                            drawables: self.get(\"drawables\")\n                        };\n                    }\n                }\n            }\n        );\n\n        /**\n * -- Routers --\n */\n\n        /**\n * Router for track browser.\n */\n        var TrackBrowserRouter = Backbone.Router.extend({\n            initialize: function(options) {\n                this.view = options.view;\n\n                // Can't put regular expression in routes dictionary.\n                // NOTE: parentheses are used to denote parameters returned to callback.\n                this.route(/([\\w]+)$/, \"change_location\");\n                this.route(/([\\w\\+]+\\:[\\d,]+-[\\d,]+)$/, \"change_location\");\n\n                // Handle navigate events from view.\n                var self = this;\n                self.view.on(\"navigate\", function(new_loc) {\n                    self.navigate(new_loc);\n                });\n            },\n\n            change_location: function(new_loc) {\n                this.view.go_to(new_loc);\n            }\n        });\n\n        return {\n            BackboneTrack: BackboneTrack,\n            BrowserBookmark: BrowserBookmark,\n            BrowserBookmarkCollection: BrowserBookmarkCollection,\n            Cache: Cache,\n            CanvasManager: CanvasManager,\n            Genome: Genome,\n            GenomeDataManager: GenomeDataManager,\n            GenomeRegion: GenomeRegion,\n            GenomeRegionCollection: GenomeRegionCollection,\n            GenomeVisualization: GenomeVisualization,\n            GenomeReferenceDataManager: GenomeReferenceDataManager,\n            TrackBrowserRouter: TrackBrowserRouter,\n            Visualization: Visualization,\n            select_datasets: select_datasets\n        };\n    }\n);\n"]}