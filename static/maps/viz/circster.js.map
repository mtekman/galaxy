{"version":3,"sources":["viz/circster.js"],"names":["require","mod_utils","cssLoadFile","define","SVGUtils","_","d3","visualization","config","mod_icon_btn","Backbone","Model","extend","is_visible","svg_elt","svg","eltBRect","svgBRect","right","$","getBoundingClientRect","left","bottom","top","UsesTicks","drawTicks","text_coords","text_anchor","data","dataHandler","horizontal","tick_coords","ticks","parent_elt","enter","append","selectAll","attr","d","angle","Math","PI","sigDigits","undefined","rval","toPrecision","roundedNum","num","round","CircsterLabelTrack","textTransform","text","label","formatNum","chords_views","model","on","vis_config","get","abs","track","toFixed","CircsterView","View","radius_start","track_gap","label_arc_height","this","genome","options","tracks_start_radii","circular_views","radius","dataset_arc_height","add_track","remove_track","self","width","update_track_bounds","height","circular_tracks","chords_tracks","get_chord_tracks","get_circular_tracks","scale","event","filter","zoom_drag_timeout","setTimeout","get_tracks_bounds","get_value","min_dimension","min","$el","el","radius_bounds","tracks_bounds","range","view","render","total_gap","outermost_radius","track_bounds","label_track_view","call","behavior","zoom","translate","new_track","innermost_radius_bounds","clearTimeout","track_index","track_view","CircsterBigWigTrackView","new_track_bounds","push","map","index","splice","remove","CircsterChromInteractionsTrackView","update_radius_bounds","length","CircsterChromLabelTrackView","CircsterTrackView","data_bounds","new_view","select","color","each","i","genome_arcs","chroms_layout","chroms_elts","track_parent_elt","tracks","render_labels","new_d","arc","_transition_chrom_data","tagName","initialize","bg_stroke","loading_bg_fill","utils","_chroms_layout","get_fill_color","data_manager","arc_gen","chrom_arc","innerRadius","layout","chrom","outerRadius","_render_chrom_data","style","num_paths","data_ready_deferred","path_data","reject","chrom_data","when","_render_data","then","chroms_paths","p_data","bg_fill","_update_data_bounds","old_bounds","new_bounds","get_data_bounds","transition","duration","chrom_arcs","rendered_deferred","update_scale","new_scale","old_scale","layout_and_data","chrom_info","data_deferred","chrom_region","get_chrom_region","can_get_more_detailed_data","get_more_detailed_data","pie_layout","value","path_elt","new_endAngle","startAngle","prototype","chrom_data_paths","get_genome_wide_data","genome_wide_data","path_fn","_get_path_function","chromArcTicks","path","_transition_labels","track_config","Deferred","set_value","silent","zip","resolve","chroms_info","get_chroms_info","init_arcs","pie","len","sort","gap_per_chrom","endAngle","click","collection","min_arc_len","visibleChroms","c","labeledChroms","v","k","CircsterQuantitativeTrackView","chord_data","chrom_chord_data","target_angle","_get_region_angle","source","_update_min_max","_quantile","numbers","quantile","ascending","chrom_angle_data","galaxy_config","add","type","viz_view","domain","linear","line","radial","menu","icon_class","select_datasets","vis","add_tracks","area","title","interpolate","on_click","dataType","id","show","vis_json","Galaxy","hide","set","ConfigSettingCollectionView","tooltip_config","new_data","flatten","_data_bounds_ticks_fn","values","p","parseInt","max","data_is_ready","cur_chrom","datum","source_angle","target","concat","chord","position","find","chrom_layout","GalaxyApp","Genome","app","GenomeVisualization","viz_config","key","hidden","dbkey","create_icon_buttons_menu","render_in_modal","modal","body","ajax","url","root","JSON","stringify","success","vis_info","vis_id","error","buttons","Cancel","window","location","placement","tooltip"],"mappings":"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","file":"../../scripts/viz/circster.js","sourcesContent":["// load required libraries\nrequire([\"utils/utils\"], function(mod_utils) {\n    // load css\n    mod_utils.cssLoadFile(\"static/style/circster.css\");\n});\n\ndefine(\n    [\n        \"libs/underscore\",\n        \"libs/d3\",\n        \"viz/visualization\",\n        \"utils/config\",\n        \"mvc/ui/icon-button\",\n        \"libs/farbtastic\"\n    ],\n    function(_, d3, visualization, config, mod_icon_btn) {\n        /**\n * Utility class for working with SVG.\n */\n        var SVGUtils = Backbone.Model.extend({\n            /**\n     * Returns true if element is visible.\n     */\n            is_visible: function(svg_elt, svg) {\n                var eltBRect = svg_elt.getBoundingClientRect(),\n                    svgBRect = $(\"svg\")[0].getBoundingClientRect();\n\n                if (\n                    // To the left of screen?\n                    eltBRect.right < 0 ||\n                    // To the right of screen?\n                    eltBRect.left > svgBRect.right ||\n                    // Above screen?\n                    eltBRect.bottom < 0 ||\n                    // Below screen?\n                    eltBRect.top > svgBRect.bottom\n                ) {\n                    return false;\n                }\n                return true;\n            }\n        });\n\n        /**\n * Mixin for using ticks.\n */\n        var UsesTicks = {\n            drawTicks: function(\n                parent_elt,\n                data,\n                dataHandler,\n                textTransform,\n                horizontal\n            ) {\n                // Set up group elements for chroms and for each tick.\n                var ticks = parent_elt\n                    .append(\"g\")\n                    .selectAll(\"g\")\n                    .data(data)\n                    .enter()\n                    .append(\"g\")\n                    .selectAll(\"g\")\n                    .data(dataHandler)\n                    .enter()\n                    .append(\"g\")\n                    .attr(\"class\", \"tick\")\n                    .attr(\"transform\", function(d) {\n                        return (\n                            \"rotate(\" +\n                            (d.angle * 180 / Math.PI - 90) +\n                            \")\" +\n                            \"translate(\" +\n                            d.radius +\n                            \",0)\"\n                        );\n                    });\n\n                // Add line + text for ticks.\n                var tick_coords = [],\n                    text_coords = [],\n                    text_anchor = function(d) {\n                        return d.angle > Math.PI ? \"end\" : null;\n                    };\n                if (horizontal) {\n                    tick_coords = [0, 0, 0, -4];\n                    text_coords = [4, 0, \"\", \".35em\"];\n                    text_anchor = null;\n                } else {\n                    tick_coords = [1, 0, 4, 0];\n                    text_coords = [0, 4, \".35em\", \"\"];\n                }\n\n                ticks\n                    .append(\"line\")\n                    .attr(\"x1\", tick_coords[0])\n                    .attr(\"y1\", tick_coords[1])\n                    .attr(\"x2\", tick_coords[2])\n                    .attr(\"y1\", tick_coords[3])\n                    .style(\"stroke\", \"#000\");\n\n                return ticks\n                    .append(\"text\")\n                    .attr(\"x\", text_coords[0])\n                    .attr(\"y\", text_coords[1])\n                    .attr(\"dx\", text_coords[2])\n                    .attr(\"dy\", text_coords[3])\n                    .attr(\"text-anchor\", text_anchor)\n                    .attr(\"transform\", textTransform)\n                    .text(function(d) {\n                        return d.label;\n                    });\n            },\n\n            /**\n     * Format number for display at a tick.\n     */\n            formatNum: function(num, sigDigits) {\n                // Use default of 2 sig. digits.\n                if (sigDigits === undefined) sigDigits = 2;\n\n                // Verify input number\n                if (num === null) return null;\n\n                // Calculate return value\n                var rval = null;\n                if (Math.abs(num) < 1) {\n                    rval = num.toPrecision(sigDigits);\n                } else {\n                    // Use round to turn string from toPrecision() back into a number.\n                    var roundedNum = Math.round(num.toPrecision(sigDigits));\n\n                    // Use abbreviations.\n                    num = Math.abs(num);\n                    if (num < 1000) {\n                        rval = roundedNum;\n                    } else if (num < 1000000) {\n                        // Use K.\n                        rval =\n                            Math.round(\n                                (roundedNum / 1000).toPrecision(3)\n                            ).toFixed(0) + \"K\";\n                    } else if (num < 1000000000) {\n                        // Use M.\n                        rval =\n                            Math.round(\n                                (roundedNum / 1000000).toPrecision(3)\n                            ).toFixed(0) + \"M\";\n                    }\n                }\n\n                return rval;\n            }\n        };\n\n        /**\n * A label track.\n */\n        var CircsterLabelTrack = Backbone.Model.extend({});\n\n        /**\n * Renders a full circster visualization.\n */\n        var CircsterView = Backbone.View.extend({\n            className: \"circster\",\n\n            initialize: function(options) {\n                this.genome = options.genome;\n                this.label_arc_height = 50;\n                this.scale = 1;\n                this.circular_views = null;\n                this.chords_views = null;\n\n                // When tracks added to/removed from model, update view.\n                this.model.get(\"drawables\").on(\"add\", this.add_track, this);\n                this.model\n                    .get(\"drawables\")\n                    .on(\"remove\", this.remove_track, this);\n\n                // When config settings change, update view.\n                var vis_config = this.model.get(\"config\");\n                vis_config\n                    .get(\"arc_dataset_height\")\n                    .on(\"change:value\", this.update_track_bounds, this);\n                vis_config\n                    .get(\"track_gap\")\n                    .on(\"change:value\", this.update_track_bounds, this);\n            },\n\n            // HACKs: using track_type for circular/chord distinction in the functions below for now.\n\n            /**\n     * Returns tracks to be rendered using circular view.\n     */\n            get_circular_tracks: function() {\n                return this.model.get(\"drawables\").filter(function(track) {\n                    return track.get(\"track_type\") !== \"DiagonalHeatmapTrack\";\n                });\n            },\n\n            /**\n     * Returns tracks to be rendered using chords view.\n     */\n            get_chord_tracks: function() {\n                return this.model.get(\"drawables\").filter(function(track) {\n                    return track.get(\"track_type\") === \"DiagonalHeatmapTrack\";\n                });\n            },\n\n            /**\n     * Returns a list of circular tracks' radius bounds.\n     */\n            get_tracks_bounds: function() {\n                var circular_tracks = this.get_circular_tracks(),\n                    dataset_arc_height = this.model\n                        .get(\"config\")\n                        .get_value(\"arc_dataset_height\"),\n                    track_gap = this.model.get(\"config\").get_value(\"track_gap\"),\n                    // Subtract 20 to make sure chrom labels are on screen.\n                    min_dimension =\n                        Math.min(this.$el.width(), this.$el.height()) - 20,\n                    // Compute radius start based on model, will be centered\n                    // and fit entirely inside element by default.\n                    radius_start =\n                        min_dimension / 2 -\n                        circular_tracks.length *\n                            (dataset_arc_height + track_gap) +\n                        // Add track_gap back in because no gap is needed for last track.\n                        track_gap -\n                        this.label_arc_height,\n                    // Compute range of track starting radii.\n                    tracks_start_radii = d3.range(\n                        radius_start,\n                        min_dimension / 2,\n                        dataset_arc_height + track_gap\n                    );\n\n                // Map from track start to bounds.\n                var self = this;\n                return _.map(tracks_start_radii, function(radius) {\n                    return [radius, radius + dataset_arc_height];\n                });\n            },\n\n            /**\n     * Renders circular tracks, chord tracks, and label tracks.\n     */\n            render: function() {\n                var self = this,\n                    width = self.$el.width(),\n                    height = self.$el.height(),\n                    circular_tracks = this.get_circular_tracks(),\n                    chords_tracks = this.get_chord_tracks(),\n                    total_gap = self.model.get(\"config\").get_value(\"total_gap\"),\n                    tracks_bounds = this.get_tracks_bounds(),\n                    // Set up SVG element.\n                    svg = d3\n                        .select(self.$el[0])\n                        .append(\"svg\")\n                        .attr(\"width\", width)\n                        .attr(\"height\", height)\n                        .attr(\"pointer-events\", \"all\")\n                        // Set up zooming, dragging.\n                        .append(\"svg:g\")\n                        .call(\n                            d3.behavior.zoom().on(\"zoom\", function() {\n                                // Do zoom, drag.\n                                var scale = d3.event.scale;\n                                svg.attr(\n                                    \"transform\",\n                                    \"translate(\" +\n                                        d3.event.translate +\n                                        \")\" +\n                                        \" scale(\" +\n                                        scale +\n                                        \")\"\n                                );\n\n                                // Propagate scale changes to views.\n                                if (self.scale !== scale) {\n                                    // Use timeout to wait for zooming/dragging to stop before rendering more detail.\n                                    if (self.zoom_drag_timeout) {\n                                        clearTimeout(self.zoom_drag_timeout);\n                                    }\n                                    self.zoom_drag_timeout = setTimeout(\n                                        function() {\n                                            // Render more detail in tracks' visible elements.\n                                            // FIXME: do not do this right now; it is not fully implemented--e.g. data bounds\n                                            // are not updated when new data is fetched--and fetching more detailed quantitative\n                                            // data is not that useful.\n                                            /*\n                            _.each(self.circular_views, function(view) {\n                                view.update_scale(scale);\n                            });\n                            */\n                                        },\n                                        400\n                                    );\n                                }\n                            })\n                        )\n                        .attr(\n                            \"transform\",\n                            \"translate(\" + width / 2 + \",\" + height / 2 + \")\"\n                        )\n                        .append(\"svg:g\")\n                        .attr(\"class\", \"tracks\");\n\n                // -- Render circular tracks. --\n\n                // Create a view for each track in the visualization and render.\n                this.circular_views = circular_tracks.map(function(\n                    track,\n                    index\n                ) {\n                    var view = new CircsterBigWigTrackView({\n                        el: svg.append(\"g\")[0],\n                        track: track,\n                        radius_bounds: tracks_bounds[index],\n                        genome: self.genome,\n                        total_gap: total_gap\n                    });\n\n                    view.render();\n\n                    return view;\n                });\n\n                // -- Render chords tracks. --\n\n                this.chords_views = chords_tracks.map(function(track) {\n                    var view = new CircsterChromInteractionsTrackView({\n                        el: svg.append(\"g\")[0],\n                        track: track,\n                        radius_bounds: tracks_bounds[0],\n                        genome: self.genome,\n                        total_gap: total_gap\n                    });\n\n                    view.render();\n\n                    return view;\n                });\n\n                // -- Render label track. --\n\n                // Track bounds are:\n                // (a) outer radius of last circular track;\n                // (b)\n                var outermost_radius = this.circular_views[\n                        this.circular_views.length - 1\n                    ].radius_bounds[1],\n                    track_bounds = [\n                        outermost_radius,\n                        outermost_radius + this.label_arc_height\n                    ];\n                this.label_track_view = new CircsterChromLabelTrackView({\n                    el: svg.append(\"g\")[0],\n                    track: new CircsterLabelTrack(),\n                    radius_bounds: track_bounds,\n                    genome: self.genome,\n                    total_gap: total_gap\n                });\n\n                this.label_track_view.render();\n            },\n\n            /**\n     * Render a single track on the outside of the current visualization.\n     */\n            add_track: function(new_track) {\n                var total_gap = this.model.get(\"config\").get_value(\"total_gap\");\n\n                if (new_track.get(\"track_type\") === \"DiagonalHeatmapTrack\") {\n                    // Added chords track.\n                    var innermost_radius_bounds = this.circular_views[0]\n                            .radius_bounds,\n                        new_view = new CircsterChromInteractionsTrackView({\n                            el: d3.select(\"g.tracks\").append(\"g\")[0],\n                            track: new_track,\n                            radius_bounds: innermost_radius_bounds,\n                            genome: this.genome,\n                            total_gap: total_gap\n                        });\n                    new_view.render();\n                    this.chords_views.push(new_view);\n                } else {\n                    // Added circular track.\n\n                    // Recompute and update circular track bounds.\n                    var new_track_bounds = this.get_tracks_bounds();\n                    _.each(this.circular_views, function(track_view, i) {\n                        track_view.update_radius_bounds(new_track_bounds[i]);\n                    });\n\n                    // Update chords tracks.\n                    _.each(this.chords_views, function(track_view) {\n                        track_view.update_radius_bounds(new_track_bounds[0]);\n                    });\n\n                    // Render new track.\n                    var track_index = this.circular_views.length,\n                        track_view = new CircsterBigWigTrackView({\n                            el: d3.select(\"g.tracks\").append(\"g\")[0],\n                            track: new_track,\n                            radius_bounds: new_track_bounds[track_index],\n                            genome: this.genome,\n                            total_gap: total_gap\n                        });\n                    track_view.render();\n                    this.circular_views.push(track_view);\n\n                    // Update label track.\n                    /*\n            FIXME: should never have to update label track because vis always expands to fit area\n            within label track.\n            var track_bounds = new_track_bounds[ new_track_bounds.length-1 ];\n            track_bounds[1] = track_bounds[0];\n            this.label_track_view.update_radius_bounds(track_bounds);\n            */\n                }\n            },\n\n            /**\n     * Remove a track from the view.\n     */\n            remove_track: function(track, tracks, options) {\n                // -- Remove track from view. --\n                var track_view = this.circular_views[options.index];\n                this.circular_views.splice(options.index, 1);\n                track_view.$el.remove();\n\n                // Recompute and update track bounds.\n                var new_track_bounds = this.get_tracks_bounds();\n                _.each(this.circular_views, function(track_view, i) {\n                    track_view.update_radius_bounds(new_track_bounds[i]);\n                });\n            },\n\n            update_track_bounds: function() {\n                // Recompute and update track bounds.\n                var new_track_bounds = this.get_tracks_bounds();\n                _.each(this.circular_views, function(track_view, i) {\n                    track_view.update_radius_bounds(new_track_bounds[i]);\n                });\n\n                // Update chords tracks.\n                _.each(this.chords_views, function(track_view) {\n                    track_view.update_radius_bounds(new_track_bounds[0]);\n                });\n            }\n        });\n\n        /**\n * Renders a track in a Circster visualization.\n */\n        var CircsterTrackView = Backbone.View.extend({\n            tagName: \"g\",\n\n            /* ----------------------- Public Methods ------------------------- */\n\n            initialize: function(options) {\n                this.bg_stroke = \"#ddd\";\n                // Fill color when loading data.\n                this.loading_bg_fill = \"#ffc\";\n                // Fill color when data has been loaded.\n                this.bg_fill = \"#ddd\";\n                this.total_gap = options.total_gap;\n                this.track = options.track;\n                this.radius_bounds = options.radius_bounds;\n                this.genome = options.genome;\n                this.chroms_layout = this._chroms_layout();\n                this.data_bounds = [];\n                this.scale = 1;\n                this.parent_elt = d3.select(this.$el[0]);\n            },\n\n            /**\n     * Get fill color from config.\n     */\n            get_fill_color: function() {\n                var color = this.track.get(\"config\").get_value(\"block_color\");\n                if (!color) {\n                    color = this.track.get(\"config\").get_value(\"color\");\n                }\n                return color;\n            },\n\n            /**\n     * Render track's data by adding SVG elements to parent.\n     */\n            render: function() {\n                // -- Create track group element. --\n                var track_parent_elt = this.parent_elt;\n\n                // -- Render background arcs. --\n                var genome_arcs = this.chroms_layout,\n                    arc_gen = d3.svg\n                        .arc()\n                        .innerRadius(this.radius_bounds[0])\n                        .outerRadius(this.radius_bounds[1]),\n                    // Attach data to group element.\n                    chroms_elts = track_parent_elt\n                        .selectAll(\"g\")\n                        .data(genome_arcs)\n                        .enter()\n                        .append(\"svg:g\"),\n                    // Draw chrom arcs/paths.\n                    chroms_paths = chroms_elts\n                        .append(\"path\")\n                        .attr(\"d\", arc_gen)\n                        .attr(\"class\", \"chrom-background\")\n                        .style(\"stroke\", this.bg_stroke)\n                        .style(\"fill\", this.loading_bg_fill);\n\n                // Append titles to paths.\n                chroms_paths.append(\"title\").text(function(d) {\n                    return d.data.chrom;\n                });\n\n                // -- Render track data and, when track data is rendered, apply preferences and update chrom_elts fill. --\n\n                var self = this,\n                    data_manager = self.track.get(\"data_manager\"),\n                    // If track has a data manager, get deferred that resolves when data is ready.\n                    data_ready_deferred = data_manager\n                        ? data_manager.data_is_ready()\n                        : true;\n\n                // When data is ready, render track.\n                $.when(data_ready_deferred).then(function() {\n                    $.when(\n                        self._render_data(track_parent_elt)\n                    ).then(function() {\n                        chroms_paths.style(\"fill\", self.bg_fill);\n\n                        // Render labels after data is available so that data attributes are available.\n                        self.render_labels();\n                    });\n                });\n            },\n\n            /**\n     * Render track labels.\n     */\n            render_labels: function() {},\n\n            /**\n     * Update radius bounds.\n     */\n            update_radius_bounds: function(radius_bounds) {\n                // Update bounds.\n                this.radius_bounds = radius_bounds;\n\n                // -- Update background arcs. --\n                var new_d = d3.svg\n                    .arc()\n                    .innerRadius(this.radius_bounds[0])\n                    .outerRadius(this.radius_bounds[1]);\n\n                this.parent_elt\n                    .selectAll(\"g>path.chrom-background\")\n                    .transition()\n                    .duration(1000)\n                    .attr(\"d\", new_d);\n\n                this._transition_chrom_data();\n\n                this._transition_labels();\n            },\n\n            /**\n     * Update view scale. This fetches more data if scale is increased.\n     */\n            update_scale: function(new_scale) {\n                // -- Update scale and return if new scale is less than old scale. --\n\n                var old_scale = this.scale;\n                this.scale = new_scale;\n                if (new_scale <= old_scale) {\n                    return;\n                }\n\n                // -- Scale increased, so render visible data with more detail. --\n\n                var self = this,\n                    utils = new SVGUtils();\n\n                // Select all chrom data and filter to operate on those that are visible.\n                this.parent_elt\n                    .selectAll(\"path.chrom-data\")\n                    .filter(function(d, i) {\n                        return utils.is_visible(this);\n                    })\n                    .each(function(d, i) {\n                        // -- Now operating on a single path element representing chromosome data. --\n\n                        var path_elt = d3.select(this),\n                            chrom = path_elt.attr(\"chrom\"),\n                            chrom_region = self.genome.get_chrom_region(chrom),\n                            data_manager = self.track.get(\"data_manager\"),\n                            data_deferred;\n\n                        // If can't get more detailed data, return.\n                        if (\n                            !data_manager.can_get_more_detailed_data(\n                                chrom_region\n                            )\n                        ) {\n                            return;\n                        }\n\n                        // -- Get more detailed data. --\n                        data_deferred = self.track\n                            .get(\"data_manager\")\n                            .get_more_detailed_data(\n                                chrom_region,\n                                \"Coverage\",\n                                0,\n                                new_scale\n                            );\n\n                        // When more data is available, use new data to redraw path.\n                        $.when(data_deferred).then(function(data) {\n                            // Remove current data path.\n                            path_elt.remove();\n\n                            // Update data bounds with new data.\n                            self._update_data_bounds();\n\n                            // Find chromosome arc to draw data on.\n                            var chrom_arc = _.find(self.chroms_layout, function(\n                                layout\n                            ) {\n                                return layout.data.chrom === chrom;\n                            });\n\n                            // Add new data path and apply preferences.\n                            var color = self.get_fill_color();\n                            self\n                                ._render_chrom_data(\n                                    self.parent_elt,\n                                    chrom_arc,\n                                    data\n                                )\n                                .style(\"stroke\", color)\n                                .style(\"fill\", color);\n                        });\n                    });\n\n                return self;\n            },\n\n            /* ----------------------- Internal Methods ------------------------- */\n\n            /**\n     * Transitions chrom data to new values (e.g new radius or data bounds).\n     */\n            _transition_chrom_data: function() {\n                var track = this.track,\n                    chrom_arcs = this.chroms_layout,\n                    chrom_data_paths = this.parent_elt.selectAll(\n                        \"g>path.chrom-data\"\n                    ),\n                    num_paths = chrom_data_paths[0].length;\n\n                if (num_paths > 0) {\n                    var self = this;\n                    $.when(\n                        track\n                            .get(\"data_manager\")\n                            .get_genome_wide_data(this.genome)\n                    ).then(function(genome_wide_data) {\n                        // Map chrom data to path data, filtering out null values.\n                        var path_data = _.reject(\n                            _.map(genome_wide_data, function(chrom_data, i) {\n                                var rval = null,\n                                    path_fn = self._get_path_function(\n                                        chrom_arcs[i],\n                                        chrom_data\n                                    );\n                                if (path_fn) {\n                                    rval = path_fn(chrom_data.data);\n                                }\n                                return rval;\n                            }),\n                            function(p_data) {\n                                return p_data === null;\n                            }\n                        );\n\n                        // Transition each path for data and color.\n                        var color = track.get(\"config\").get_value(\"color\");\n                        chrom_data_paths.each(function(path, index) {\n                            d3\n                                .select(this)\n                                .transition()\n                                .duration(1000)\n                                .style(\"stroke\", color)\n                                .style(\"fill\", color)\n                                .attr(\"d\", path_data[index]);\n                        });\n                    });\n                }\n            },\n\n            /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n            _transition_labels: function() {},\n\n            /**\n     * Update data bounds. If there are new_bounds, use them; otherwise use\n     * default data bounds.\n     */\n            _update_data_bounds: function(new_bounds) {\n                var old_bounds = this.data_bounds;\n                this.data_bounds =\n                    new_bounds ||\n                    this.get_data_bounds(\n                        this.track\n                            .get(\"data_manager\")\n                            .get_genome_wide_data(this.genome)\n                    );\n                this._transition_chrom_data();\n            },\n\n            /**\n     * Render data as elements attached to svg.\n     */\n            _render_data: function(svg) {\n                var self = this,\n                    chrom_arcs = this.chroms_layout,\n                    track = this.track,\n                    rendered_deferred = $.Deferred();\n\n                // When genome-wide data is available, render data.\n                $.when(\n                    track.get(\"data_manager\").get_genome_wide_data(this.genome)\n                ).then(function(genome_wide_data) {\n                    // Set bounds.\n                    self.data_bounds = self.get_data_bounds(genome_wide_data);\n\n                    // Set min, max value in config so that they can be adjusted. Make this silent\n                    // because these attributes are watched for changes and the viz is updated\n                    // accordingly (set up in initialize). Because we are setting up, we don't want\n                    // the watch to trigger events here.\n                    track\n                        .get(\"config\")\n                        .set_value(\"min_value\", self.data_bounds[0], {\n                            silent: true\n                        });\n                    track\n                        .get(\"config\")\n                        .set_value(\"max_value\", self.data_bounds[1], {\n                            silent: true\n                        });\n\n                    // Merge chroms layout with data.\n                    var layout_and_data = _.zip(chrom_arcs, genome_wide_data);\n\n                    // Render each chromosome's data.\n                    _.each(layout_and_data, function(chrom_info) {\n                        var chrom_arc = chrom_info[0],\n                            data = chrom_info[1];\n                        return self._render_chrom_data(svg, chrom_arc, data);\n                    });\n\n                    // Apply prefs to all track data.\n                    var color = self.get_fill_color();\n                    self.parent_elt\n                        .selectAll(\"path.chrom-data\")\n                        .style(\"stroke\", color)\n                        .style(\"fill\", color);\n\n                    rendered_deferred.resolve(svg);\n                });\n\n                return rendered_deferred;\n            },\n\n            /**\n     * Render a chromosome data and attach elements to svg.\n     */\n            _render_chrom_data: function(svg, chrom_arc, data) {},\n\n            /**\n     * Returns data for creating a path for the given data using chrom_arc and data bounds.\n     */\n            _get_path_function: function(chrom_arc, chrom_data) {},\n\n            /**\n     * Returns arc layouts for genome's chromosomes/contigs. Arcs are arranged in a circle\n     * separated by gaps.\n     */\n            _chroms_layout: function() {\n                // Setup chroms layout using pie.\n                var chroms_info = this.genome.get_chroms_info(),\n                    pie_layout = d3.layout\n                        .pie()\n                        .value(function(d) {\n                            return d.len;\n                        })\n                        .sort(null),\n                    init_arcs = pie_layout(chroms_info),\n                    gap_per_chrom =\n                        2 * Math.PI * this.total_gap / chroms_info.length,\n                    chrom_arcs = _.map(init_arcs, function(arc, index) {\n                        // For short chroms, endAngle === startAngle.\n                        var new_endAngle = arc.endAngle - gap_per_chrom;\n                        arc.endAngle =\n                            new_endAngle > arc.startAngle\n                                ? new_endAngle\n                                : arc.startAngle;\n                        return arc;\n                    });\n                return chrom_arcs;\n            }\n        });\n\n        /**\n * Render chromosome labels.\n */\n        var CircsterChromLabelTrackView = CircsterTrackView.extend({\n            initialize: function(options) {\n                CircsterTrackView.prototype.initialize.call(this, options);\n                // Use a single arc for rendering data.\n                this.innerRadius = this.radius_bounds[0];\n                this.radius_bounds[0] = this.radius_bounds[1];\n                this.bg_stroke = \"#fff\";\n                this.bg_fill = \"#fff\";\n\n                // Minimum arc distance for labels to be applied.\n                this.min_arc_len = 0.05;\n            },\n\n            /**\n     * Render labels.\n     */\n            _render_data: function(svg) {\n                // -- Add chromosome label where it will fit; an alternative labeling mechanism\n                // would be nice for small chromosomes. --\n                var self = this,\n                    chrom_arcs = svg.selectAll(\"g\");\n\n                chrom_arcs.selectAll(\"path\").attr(\"id\", function(d) {\n                    return \"label-\" + d.data.chrom;\n                });\n\n                chrom_arcs\n                    .append(\"svg:text\")\n                    .filter(function(d) {\n                        return d.endAngle - d.startAngle > self.min_arc_len;\n                    })\n                    .attr(\"text-anchor\", \"middle\")\n                    .append(\"svg:textPath\")\n                    .attr(\"class\", \"chrom-label\")\n                    .attr(\"xlink:href\", function(d) {\n                        return \"#label-\" + d.data.chrom;\n                    })\n                    .attr(\"startOffset\", \"25%\")\n                    .text(function(d) {\n                        return d.data.chrom;\n                    });\n\n                // -- Add ticks to denote chromosome length. --\n\n                /** Returns an array of tick angles and labels, given a chrom arc. */\n                var chromArcTicks = function(d) {\n                    var k = (d.endAngle - d.startAngle) / d.value,\n                        ticks = d3\n                            .range(0, d.value, 25000000)\n                            .map(function(v, i) {\n                                return {\n                                    radius: self.innerRadius,\n                                    angle: v * k + d.startAngle,\n                                    label:\n                                        i === 0\n                                            ? 0\n                                            : i % 3 ? null : self.formatNum(v)\n                                };\n                            });\n\n                    // If there are fewer that 4 ticks, label last tick so that at least one non-zero tick is labeled.\n                    if (ticks.length < 4) {\n                        ticks[ticks.length - 1].label = self.formatNum(\n                            Math.round(\n                                (ticks[ticks.length - 1].angle - d.startAngle) /\n                                    k\n                            )\n                        );\n                    }\n\n                    return ticks;\n                };\n\n                /** Rotate and move text as needed. */\n                var textTransform = function(d) {\n                    return d.angle > Math.PI\n                        ? \"rotate(180)translate(-16)\"\n                        : null;\n                };\n\n                // Filter chroms for only those large enough for display.\n                var visibleChroms = _.filter(this.chroms_layout, function(c) {\n                    return c.endAngle - c.startAngle > self.min_arc_len;\n                });\n\n                this.drawTicks(\n                    this.parent_elt,\n                    visibleChroms,\n                    chromArcTicks,\n                    textTransform\n                );\n            }\n        });\n        _.extend(CircsterChromLabelTrackView.prototype, UsesTicks);\n\n        /**\n * View for quantitative track in Circster.\n */\n        var CircsterQuantitativeTrackView = CircsterTrackView.extend({\n            initialize: function(options) {\n                CircsterTrackView.prototype.initialize.call(this, options);\n\n                // When config settings change, update view.\n                var track_config = this.track.get(\"config\");\n                track_config\n                    .get(\"min_value\")\n                    .on(\"change:value\", this._update_min_max, this);\n                track_config\n                    .get(\"max_value\")\n                    .on(\"change:value\", this._update_min_max, this);\n                track_config\n                    .get(\"color\")\n                    .on(\"change:value\", this._transition_chrom_data, this);\n            },\n\n            /**\n     * Update track when min and/or max are changed.\n     */\n            _update_min_max: function() {\n                var track_config = this.track.get(\"config\"),\n                    new_bounds = [\n                        track_config.get_value(\"min_value\"),\n                        track_config.get_value(\"max_value\")\n                    ];\n                this._update_data_bounds(new_bounds);\n\n                // FIXME: this works to update tick/text bounds, but there's probably a better way to do this\n                // by updating the data itself.\n                this.parent_elt.selectAll(\".min_max\").text(function(d, i) {\n                    return new_bounds[i];\n                });\n            },\n\n            /**\n     * Returns quantile for an array of numbers.\n     */\n            _quantile: function(numbers, quantile) {\n                numbers.sort(d3.ascending);\n                return d3.quantile(numbers, quantile);\n            },\n\n            /**\n     * Renders quantitative data with the form [x, value] and assumes data is equally spaced across\n     * chromosome. Attachs a dict with track and chrom name information to DOM element.\n     */\n            _render_chrom_data: function(svg, chrom_arc, chrom_data) {\n                var path_data = this._get_path_function(chrom_arc, chrom_data);\n\n                if (!path_data) {\n                    return null;\n                }\n\n                // There is path data, so render as path.\n                var parent = svg.datum(chrom_data.data),\n                    path = parent\n                        .append(\"path\")\n                        .attr(\"class\", \"chrom-data\")\n                        .attr(\"chrom\", chrom_arc.data.chrom)\n                        .attr(\"d\", path_data);\n\n                return path;\n            },\n\n            /**\n     * Returns function for creating a path across the chrom arc.\n     */\n            _get_path_function: function(chrom_arc, chrom_data) {\n                // If no chrom data, return null.\n                if (\n                    typeof chrom_data === \"string\" ||\n                    !chrom_data.data ||\n                    chrom_data.data.length === 0\n                ) {\n                    return null;\n                }\n\n                // Radius scaler.\n                var radius = d3.scale\n                    .linear()\n                    .domain(this.data_bounds)\n                    .range(this.radius_bounds)\n                    .clamp(true);\n\n                // Scaler for placing data points across arc.\n                var angle = d3.scale\n                    .linear()\n                    .domain([0, chrom_data.data.length])\n                    .range([chrom_arc.startAngle, chrom_arc.endAngle]);\n\n                // Use line generator to create area.\n                var line = d3.svg.line\n                    .radial()\n                    .interpolate(\"linear\")\n                    .radius(function(d) {\n                        return radius(d[1]);\n                    })\n                    .angle(function(d, i) {\n                        return angle(i);\n                    });\n\n                return d3.svg.area\n                    .radial()\n                    .interpolate(line.interpolate())\n                    .innerRadius(radius(0))\n                    .outerRadius(line.radius())\n                    .angle(line.angle());\n            },\n\n            /**\n     * Render track min, max using ticks.\n     */\n            render_labels: function() {\n                var self = this,\n                    // Keep counter of visible chroms.\n                    textTransform = function() {\n                        return \"rotate(90)\";\n                    };\n\n                // FIXME:\n                // (1) using min_max class below is needed for _update_min_max, which could be improved.\n                // (2) showing config on tick click should be replaced by proper track config icon.\n\n                // Draw min, max on first chrom only.\n                var ticks = this.drawTicks(\n                    this.parent_elt,\n                    [this.chroms_layout[0]],\n                    this._data_bounds_ticks_fn(),\n                    textTransform,\n                    true\n                ).classed(\"min_max\", true);\n\n                // Show config when ticks are clicked on.\n                _.each(ticks, function(tick) {\n                    $(tick).click(function() {\n                        var view = new config.ConfigSettingCollectionView({\n                            collection: self.track.get(\"config\")\n                        });\n                        view.render_in_modal(\"Configure Track\");\n                    });\n                });\n\n                /*\n        // Filter for visible chroms, then for every third chrom so that labels attached to only every\n        // third chrom.\n        var visibleChroms = _.filter(this.chroms_layout, function(c) { return c.endAngle - c.startAngle > 0.08; }),\n            labeledChroms = _.filter(visibleChroms, function(c, i) { return i % 3 === 0; });\n        this.drawTicks(this.parent_elt, labeledChroms, this._data_bounds_ticks_fn(), textTransform, true);\n        */\n            },\n\n            /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n            _transition_labels: function() {\n                // FIXME: (a) pull out function for getting labeled chroms? and (b) function used in transition below\n                // is copied from UseTicks mixin, so pull out and make generally available.\n\n                // If there are no data bounds, nothing to transition.\n                if (this.data_bounds.length === 0) {\n                    return;\n                }\n\n                // Transition labels to new radius bounds.\n                var self = this,\n                    visibleChroms = _.filter(this.chroms_layout, function(c) {\n                        return c.endAngle - c.startAngle > 0.08;\n                    }),\n                    labeledChroms = _.filter(visibleChroms, function(c, i) {\n                        return i % 3 === 0;\n                    }),\n                    new_data = _.flatten(\n                        _.map(labeledChroms, function(c) {\n                            return self._data_bounds_ticks_fn()(c);\n                        })\n                    );\n                this.parent_elt\n                    .selectAll(\"g.tick\")\n                    .data(new_data)\n                    .transition()\n                    .attr(\"transform\", function(d) {\n                        return (\n                            \"rotate(\" +\n                            (d.angle * 180 / Math.PI - 90) +\n                            \")\" +\n                            \"translate(\" +\n                            d.radius +\n                            \",0)\"\n                        );\n                    });\n            },\n\n            /**\n     * Get function for locating data bounds ticks.\n     */\n            _data_bounds_ticks_fn: function() {\n                // Closure vars.\n                var self = this;\n                visibleChroms = 0;\n\n                // Return function for locating ticks based on chrom arc data.\n                return function(d) {\n                    // Set up data to display min, max ticks.\n                    return [\n                        {\n                            radius: self.radius_bounds[0],\n                            angle: d.startAngle,\n                            label: self.formatNum(self.data_bounds[0])\n                        },\n                        {\n                            radius: self.radius_bounds[1],\n                            angle: d.startAngle,\n                            label: self.formatNum(self.data_bounds[1])\n                        }\n                    ];\n                };\n            },\n\n            /**\n     * Returns an array with two values denoting the minimum and maximum\n     * values for the track.\n     */\n            get_data_bounds: function(data) {}\n        });\n        _.extend(CircsterQuantitativeTrackView.prototype, UsesTicks);\n\n        /**\n * Bigwig track view in Circster.\n */\n        var CircsterBigWigTrackView = CircsterQuantitativeTrackView.extend({\n            get_data_bounds: function(data) {\n                // Set max across dataset by extracting all values, flattening them into a\n                // single array, and getting third quartile.\n                var values = _.flatten(\n                    _.map(data, function(d) {\n                        if (d) {\n                            // Each data point has the form [position, value], so return all values.\n                            return _.map(d.data, function(p) {\n                                // Null is used for a lack of data; resolve null to 0 for comparison.\n                                return parseInt(p[1], 10) || 0;\n                            });\n                        } else {\n                            return 0;\n                        }\n                    })\n                );\n\n                // For max, use 98% quantile in attempt to avoid very large values. However, this max may be 0\n                // for sparsely populated data, so use max in that case.\n                return [\n                    _.min(values),\n                    this._quantile(values, 0.98) || _.max(values)\n                ];\n            }\n        });\n\n        /**\n * Chromosome interactions track view in Circster.\n */\n        var CircsterChromInteractionsTrackView = CircsterTrackView.extend({\n            render: function() {\n                var self = this;\n\n                // When data is ready, render track.\n                $.when(\n                    self.track.get(\"data_manager\").data_is_ready()\n                ).then(function() {\n                    // When data has been fetched, render track.\n                    $.when(\n                        self.track\n                            .get(\"data_manager\")\n                            .get_genome_wide_data(self.genome)\n                    ).then(function(genome_wide_data) {\n                        var chord_data = [],\n                            chroms_info = self.genome.get_chroms_info();\n                        // Convert chromosome data into chord data.\n                        _.each(genome_wide_data, function(chrom_data, index) {\n                            // Map each interaction into chord data.\n                            var cur_chrom = chroms_info[index].chrom;\n                            var chrom_chord_data = _.map(\n                                chrom_data.data,\n                                function(datum) {\n                                    // Each datum is an interaction/chord.\n                                    var source_angle = self._get_region_angle(\n                                            cur_chrom,\n                                            datum[1]\n                                        ),\n                                        target_angle = self._get_region_angle(\n                                            datum[3],\n                                            datum[4]\n                                        );\n                                    return {\n                                        source: {\n                                            startAngle: source_angle,\n                                            endAngle: source_angle + 0.01\n                                        },\n                                        target: {\n                                            startAngle: target_angle,\n                                            endAngle: target_angle + 0.01\n                                        }\n                                    };\n                                }\n                            );\n\n                            chord_data = chord_data.concat(chrom_chord_data);\n                        });\n\n                        self.parent_elt\n                            .append(\"g\")\n                            .attr(\"class\", \"chord\")\n                            .selectAll(\"path\")\n                            .data(chord_data)\n                            .enter()\n                            .append(\"path\")\n                            .style(\"fill\", self.get_fill_color())\n                            .attr(\n                                \"d\",\n                                d3.svg.chord().radius(self.radius_bounds[0])\n                            )\n                            .style(\"opacity\", 1);\n                    });\n                });\n            },\n\n            update_radius_bounds: function(radius_bounds) {\n                this.radius_bounds = radius_bounds;\n                this.parent_elt\n                    .selectAll(\"path\")\n                    .transition()\n                    .attr(\"d\", d3.svg.chord().radius(this.radius_bounds[0]));\n            },\n\n            /**\n     * Returns radians for a genomic position.\n     */\n            _get_region_angle: function(chrom, position) {\n                // Find chrom angle data\n                var chrom_angle_data = _.find(this.chroms_layout, function(\n                    chrom_layout\n                ) {\n                    return chrom_layout.data.chrom === chrom;\n                });\n\n                // Return angle at position.\n                return (\n                    chrom_angle_data.endAngle -\n                    (chrom_angle_data.endAngle - chrom_angle_data.startAngle) *\n                        (chrom_angle_data.data.len - position) /\n                        chrom_angle_data.data.len\n                );\n            }\n        });\n\n        // circster app loader\n        var Circster = Backbone.View.extend({\n            initialize: function() {\n                // -- Configure visualization --\n                var genome = new visualization.Genome(galaxy_config.app.genome),\n                    vis = new visualization.GenomeVisualization(\n                        galaxy_config.app.viz_config\n                    );\n\n                // Add Circster-specific config options.\n                vis.get(\"config\").add([\n                    {\n                        key: \"arc_dataset_height\",\n                        label: \"Arc Dataset Height\",\n                        type: \"int\",\n                        value: 25,\n                        view: \"circster\"\n                    },\n                    {\n                        key: \"track_gap\",\n                        label: \"Gap Between Tracks\",\n                        type: \"int\",\n                        value: 5,\n                        view: \"circster\"\n                    },\n                    {\n                        key: \"total_gap\",\n                        label: \"Gap [0-1]\",\n                        type: \"float\",\n                        value: 0.4,\n                        view: \"circster\",\n                        hidden: true\n                    }\n                ]);\n\n                var viz_view = new CircsterView({\n                    // view pane\n                    el: $(\"#center .unified-panel-body\"),\n                    genome: genome,\n                    model: vis\n                });\n\n                // Render vizualization\n                viz_view.render();\n\n                // setup title\n                $(\"#center .unified-panel-header-inner\").append(\n                    galaxy_config.app.viz_config.title +\n                        \" \" +\n                        galaxy_config.app.viz_config.dbkey\n                );\n\n                // setup menu\n                var menu = mod_icon_btn.create_icon_buttons_menu(\n                    [\n                        {\n                            icon_class: \"plus-button\",\n                            title: \"Add tracks\",\n                            on_click: function() {\n                                visualization.select_datasets(\n                                    { dbkey: vis.get(\"dbkey\") },\n                                    function(tracks) {\n                                        vis.add_tracks(tracks);\n                                    }\n                                );\n                            }\n                        },\n                        {\n                            icon_class: \"gear\",\n                            title: \"Settings\",\n                            on_click: function() {\n                                var view = new config.ConfigSettingCollectionView(\n                                    {\n                                        collection: vis.get(\"config\")\n                                    }\n                                );\n                                view.render_in_modal(\"Configure Visualization\");\n                            }\n                        },\n                        {\n                            icon_class: \"disk--arrow\",\n                            title: \"Save\",\n                            on_click: function() {\n                                // show saving dialog box\n                                Galaxy.modal.show({\n                                    title: \"Saving...\",\n                                    body: \"progress\"\n                                });\n\n                                // send to server\n                                $.ajax({\n                                    url: Galaxy.root + \"visualization/save\",\n                                    type: \"POST\",\n                                    dataType: \"json\",\n                                    data: {\n                                        id: vis.get(\"vis_id\"),\n                                        title: vis.get(\"title\"),\n                                        dbkey: vis.get(\"dbkey\"),\n                                        type: \"trackster\",\n                                        vis_json: JSON.stringify(vis)\n                                    }\n                                })\n                                    .success(function(vis_info) {\n                                        Galaxy.modal.hide();\n                                        vis.set(\"vis_id\", vis_info.vis_id);\n                                    })\n                                    .error(function() {\n                                        // show dialog\n                                        Galaxy.modal.show({\n                                            title: \"Could Not Save\",\n                                            body:\n                                                \"Could not save visualization. Please try again later.\",\n                                            buttons: {\n                                                Cancel: function() {\n                                                    Galaxy.modal.hide();\n                                                }\n                                            }\n                                        });\n                                    });\n                            }\n                        },\n                        {\n                            icon_class: \"cross-circle\",\n                            title: \"Close\",\n                            on_click: function() {\n                                window.location =\n                                    Galaxy.root + \"visualizations/list\";\n                            }\n                        }\n                    ],\n                    { tooltip_config: { placement: \"bottom\" } }\n                );\n\n                // add menu\n                menu.$el.attr(\"style\", \"float: right\");\n                $(\"#center .unified-panel-header-inner\").append(menu.$el);\n\n                // manual tooltip config because default gravity is S and cannot be changed\n                $(\".menu-button\").tooltip({ placement: \"bottom\" });\n            }\n        });\n\n        // Module exports.\n        return {\n            GalaxyApp: Circster\n        };\n    }\n);\n"]}