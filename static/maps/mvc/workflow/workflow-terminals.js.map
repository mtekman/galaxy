{"version":3,"sources":["mvc/workflow/workflow-terminals.js"],"names":["define","Globals","CollectionTypeDescription","collectionType","this","length","NULL_COLLECTION_TYPE_DESCRIPTION","isCollection","canMapOver","other","toString","append","otherCollectionType","equal","ANY_COLLECTION_TYPE_DESCRIPTION","$","extend","prototype","otherCollectionTypeDescription","canMatch","effectiveMapOver","_endsWith","TerminalMapping","Backbone","rank","mapOver","requiredSuffix","terminalMapping","setMapOver","collectionTypeDescription","substring","Terminal","initialize","element","connect","connectors","connector","markChanged","str","indexOf","suffix","Model","resetMappingIfNeeded","terminal","attr","c","trigger","push","node","outputTerminal","splice","inArray","redraw","each","destroy","slice","_","resetMapping","destroyInvalidConnections","destroyIfInvalid","val","output_terminals","hasConnectedOutputTerminals","noMappedInputs","isMappedOver","disableMapOver","OutputTerminal","call","BaseInputTerminal","input","hasConnectedMappedInputTerminals","mappedInputTerminals","mappedInput","hasMappedOverInputTerminals","connectedInput","handle2","_inputFilled","inputFilled","attachable","_collectionAttached","connected","firstOutput","_mappingConstraints","constraints","inputTerminal","_producesAcceptableDatatype","thisDatatype","handle1","post_job_actions","other_datatype","_otherCollectionType","otherMapOver","InputTerminal","first","values","collection","other_output","datatypes","t","cat_outputs","pja_i","pja","thisMapOver","action_type","multiple","output_name","name","action_arguments","other_datatype_i","mappingConstraints","InputCollectionTerminal","extensions","update","collectionTypes","collection_types","_effectiveMapOver","every","bind","OutputCollectionTerminal","collection_type","console","some","output","newCollectionType","collectionTypeSource","collection_type_source","collectionTypeIndex","_effectiveCollectionTypes","effectiveCollectionType","log"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-terminals.js","sourcesContent":["define([\"mvc/workflow/workflow-globals\"], function(Globals) {\n    function CollectionTypeDescription(collectionType) {\n        this.collectionType = collectionType;\n        this.isCollection = true;\n        this.rank = collectionType.split(\":\").length;\n    }\n\n    var NULL_COLLECTION_TYPE_DESCRIPTION = {\n        isCollection: false,\n        canMatch: function(other) {\n            return false;\n        },\n        canMapOver: function(other) {\n            return false;\n        },\n        toString: function() {\n            return \"NullCollectionType[]\";\n        },\n        append: function(otherCollectionType) {\n            return otherCollectionType;\n        },\n        equal: function(other) {\n            return other === this;\n        }\n    };\n\n    var ANY_COLLECTION_TYPE_DESCRIPTION = {\n        isCollection: true,\n        canMatch: function(other) {\n            return NULL_COLLECTION_TYPE_DESCRIPTION !== other;\n        },\n        canMapOver: function(other) {\n            return false;\n        },\n        toString: function() {\n            return \"AnyCollectionType[]\";\n        },\n        append: function(otherCollectionType) {\n            throw \"Cannot append to ANY_COLLECTION_TYPE_DESCRIPTION\";\n        },\n        equal: function(other) {\n            return other === this;\n        }\n    };\n\n    $.extend(CollectionTypeDescription.prototype, {\n        append: function(otherCollectionTypeDescription) {\n            if (\n                otherCollectionTypeDescription ===\n                NULL_COLLECTION_TYPE_DESCRIPTION\n            ) {\n                return this;\n            }\n            if (\n                otherCollectionTypeDescription ===\n                ANY_COLLECTION_TYPE_DESCRIPTION\n            ) {\n                return otherCollectionType;\n            }\n            return new CollectionTypeDescription(\n                this.collectionType +\n                    \":\" +\n                    otherCollectionTypeDescription.collectionType\n            );\n        },\n        canMatch: function(otherCollectionTypeDescription) {\n            if (\n                otherCollectionTypeDescription ===\n                NULL_COLLECTION_TYPE_DESCRIPTION\n            ) {\n                return false;\n            }\n            if (\n                otherCollectionTypeDescription ===\n                ANY_COLLECTION_TYPE_DESCRIPTION\n            ) {\n                return true;\n            }\n            return (\n                otherCollectionTypeDescription.collectionType ==\n                this.collectionType\n            );\n        },\n        canMapOver: function(otherCollectionTypeDescription) {\n            if (\n                otherCollectionTypeDescription ===\n                NULL_COLLECTION_TYPE_DESCRIPTION\n            ) {\n                return false;\n            }\n            if (\n                otherCollectionTypeDescription ===\n                ANY_COLLECTION_TYPE_DESCRIPTION\n            ) {\n                return false;\n            }\n            if (this.rank <= otherCollectionTypeDescription.rank) {\n                // Cannot map over self...\n                return false;\n            }\n            var requiredSuffix = otherCollectionTypeDescription.collectionType;\n            return this._endsWith(this.collectionType, requiredSuffix);\n        },\n        effectiveMapOver: function(otherCollectionTypeDescription) {\n            var otherCollectionType =\n                otherCollectionTypeDescription.collectionType;\n            var effectiveCollectionType = this.collectionType.substring(\n                0,\n                this.collectionType.length - otherCollectionType.length - 1\n            );\n            return new CollectionTypeDescription(effectiveCollectionType);\n        },\n        equal: function(otherCollectionTypeDescription) {\n            return (\n                otherCollectionTypeDescription.collectionType ==\n                this.collectionType\n            );\n        },\n        toString: function() {\n            return \"CollectionType[\" + this.collectionType + \"]\";\n        },\n        _endsWith: function(str, suffix) {\n            return str.indexOf(suffix, str.length - suffix.length) !== -1;\n        }\n    });\n\n    var TerminalMapping = Backbone.Model.extend({\n        initialize: function(attr) {\n            this.mapOver = attr.mapOver || NULL_COLLECTION_TYPE_DESCRIPTION;\n            this.terminal = attr.terminal;\n            this.terminal.terminalMapping = this;\n        },\n        disableMapOver: function() {\n            this.setMapOver(NULL_COLLECTION_TYPE_DESCRIPTION);\n        },\n        setMapOver: function(collectionTypeDescription) {\n            // TODO: Can I use \"attributes\" or something to auto trigger \"change\"\n            // event?\n            this.mapOver = collectionTypeDescription;\n            this.trigger(\"change\");\n        }\n    });\n\n    var Terminal = Backbone.Model.extend({\n        initialize: function(attr) {\n            this.element = attr.element;\n            this.connectors = [];\n        },\n        connect: function(connector) {\n            this.connectors.push(connector);\n            if (this.node) {\n                this.node.markChanged();\n            }\n        },\n        disconnect: function(connector) {\n            this.connectors.splice($.inArray(connector, this.connectors), 1);\n            if (this.node) {\n                this.node.markChanged();\n                this.resetMappingIfNeeded();\n            }\n        },\n        redraw: function() {\n            $.each(this.connectors, function(_, c) {\n                c.redraw();\n            });\n        },\n        destroy: function() {\n            $.each(this.connectors.slice(), function(_, c) {\n                c.destroy();\n            });\n        },\n        destroyInvalidConnections: function() {\n            _.each(this.connectors, function(connector) {\n                connector && connector.destroyIfInvalid();\n            });\n        },\n        setMapOver: function(val) {\n            if (this.multiple) {\n                return; // Cannot set this to be multirun...\n            }\n\n            if (!this.mapOver().equal(val)) {\n                this.terminalMapping.setMapOver(val);\n                _.each(this.node.output_terminals, function(outputTerminal) {\n                    outputTerminal.setMapOver(val);\n                });\n            }\n        },\n        mapOver: function() {\n            if (!this.terminalMapping) {\n                return NULL_COLLECTION_TYPE_DESCRIPTION;\n            } else {\n                return this.terminalMapping.mapOver;\n            }\n        },\n        isMappedOver: function() {\n            return (\n                this.terminalMapping &&\n                this.terminalMapping.mapOver.isCollection\n            );\n        },\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n        },\n\n        resetMappingIfNeeded: function() {} // Subclasses should override this...\n    });\n\n    var OutputTerminal = Terminal.extend({\n        initialize: function(attr) {\n            Terminal.prototype.initialize.call(this, attr);\n            this.datatypes = attr.datatypes;\n        },\n\n        resetMappingIfNeeded: function() {\n            // If inputs were only mapped over to preserve\n            // an output just disconnected reset these...\n            if (\n                !this.node.hasConnectedOutputTerminals() &&\n                !this.node.hasConnectedMappedInputTerminals()\n            ) {\n                _.each(this.node.mappedInputTerminals(), function(mappedInput) {\n                    mappedInput.resetMappingIfNeeded();\n                });\n            }\n\n            var noMappedInputs = !this.node.hasMappedOverInputTerminals();\n            if (noMappedInputs) {\n                this.resetMapping();\n            }\n        },\n\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n            _.each(this.connectors, function(connector) {\n                var connectedInput = connector.handle2;\n                if (connectedInput) {\n                    // Not exactly right because this is still connected.\n                    // Either rewrite resetMappingIfNeeded or disconnect\n                    // and reconnect if valid.\n                    connectedInput.resetMappingIfNeeded();\n                    connector.destroyIfInvalid();\n                }\n            });\n        }\n    });\n\n    var BaseInputTerminal = Terminal.extend({\n        initialize: function(attr) {\n            Terminal.prototype.initialize.call(this, attr);\n            this.update(attr.input); // subclasses should implement this...\n        },\n        canAccept: function(other) {\n            if (this._inputFilled()) {\n                return false;\n            } else {\n                return this.attachable(other);\n            }\n        },\n        resetMappingIfNeeded: function() {\n            var mapOver = this.mapOver();\n            if (!mapOver.isCollection) {\n                return;\n            }\n            // No output terminals are counting on this being mapped\n            // over if connected inputs are still mapped over or if none\n            // of the outputs are connected...\n            var reset =\n                this.node.hasConnectedMappedInputTerminals() ||\n                !this.node.hasConnectedOutputTerminals();\n            if (reset) {\n                this.resetMapping();\n            }\n        },\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n            if (!this.node.hasMappedOverInputTerminals()) {\n                _.each(this.node.output_terminals, function(terminal) {\n                    // This shouldn't be called if there are mapped over\n                    // outputs.\n                    terminal.resetMapping();\n                });\n            }\n        },\n        connected: function() {\n            return this.connectors.length !== 0;\n        },\n        _inputFilled: function() {\n            var inputFilled;\n            if (!this.connected()) {\n                inputFilled = false;\n            } else {\n                if (this.multiple) {\n                    if (this._collectionAttached()) {\n                        // Can only attach one collection to multiple input\n                        // data parameter.\n                        inputsFilled = true;\n                    } else {\n                        inputFilled = false;\n                    }\n                } else {\n                    inputFilled = true;\n                }\n            }\n            return inputFilled;\n        },\n        _collectionAttached: function() {\n            if (!this.connected()) {\n                return false;\n            } else {\n                var firstOutput = this.connectors[0].handle1;\n                if (!firstOutput) {\n                    return false;\n                } else {\n                    if (\n                        firstOutput.isCollection ||\n                        firstOutput.isMappedOver() ||\n                        firstOutput.datatypes.indexOf(\"input_collection\") > 0\n                    ) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            }\n        },\n        _mappingConstraints: function() {\n            // If this is a connected terminal, return list of collection types\n            // other terminals connected to node are constraining mapping to.\n            if (!this.node) {\n                return []; // No node - completely unconstrained\n            }\n            var mapOver = this.mapOver();\n            if (mapOver.isCollection) {\n                return [mapOver];\n            }\n\n            var constraints = [];\n            if (!this.node.hasConnectedOutputTerminals()) {\n                _.each(this.node.connectedMappedInputTerminals(), function(\n                    inputTerminal\n                ) {\n                    constraints.push(inputTerminal.mapOver());\n                });\n            } else {\n                // All outputs should have same mapOver status - least specific.\n                constraints.push(\n                    _.first(_.values(this.node.output_terminals)).mapOver()\n                );\n            }\n            return constraints;\n        },\n        _producesAcceptableDatatype: function(other) {\n            // other is a non-collection output...\n            for (var t in this.datatypes) {\n                var thisDatatype = this.datatypes[t];\n                if (thisDatatype == \"input\") {\n                    return true;\n                }\n                var cat_outputs = new Array();\n                cat_outputs = cat_outputs.concat(other.datatypes);\n                if (other.node.post_job_actions) {\n                    for (var pja_i in other.node.post_job_actions) {\n                        var pja = other.node.post_job_actions[pja_i];\n                        if (\n                            pja.action_type == \"ChangeDatatypeAction\" &&\n                            (pja.output_name == \"\" ||\n                                pja.output_name == other.name) &&\n                            pja.action_arguments\n                        ) {\n                            cat_outputs.push(pja.action_arguments[\"newtype\"]);\n                        }\n                    }\n                }\n                // FIXME: No idea what to do about case when datatype is 'input'\n                for (var other_datatype_i in cat_outputs) {\n                    var other_datatype = cat_outputs[other_datatype_i];\n                    if (\n                        other_datatype == \"input\" ||\n                        other_datatype == \"_sniff_\" ||\n                        other_datatype == \"input_collection\" ||\n                        Globals.app.isSubType(\n                            cat_outputs[other_datatype_i],\n                            thisDatatype\n                        )\n                    ) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        _otherCollectionType: function(other) {\n            var otherCollectionType = NULL_COLLECTION_TYPE_DESCRIPTION;\n            if (other.isCollection) {\n                otherCollectionType = other.collectionType;\n            }\n            var otherMapOver = other.mapOver();\n            if (otherMapOver.isCollection) {\n                otherCollectionType = otherMapOver.append(otherCollectionType);\n            }\n            return otherCollectionType;\n        }\n    });\n\n    var InputTerminal = BaseInputTerminal.extend({\n        update: function(input) {\n            this.datatypes = input.extensions;\n            this.multiple = input.multiple;\n            this.collection = false;\n        },\n        connect: function(connector) {\n            BaseInputTerminal.prototype.connect.call(this, connector);\n            var other_output = connector.handle1;\n            if (!other_output) {\n                return;\n            }\n            var otherCollectionType = this._otherCollectionType(other_output);\n            if (otherCollectionType.isCollection) {\n                this.setMapOver(otherCollectionType);\n            }\n        },\n        attachable: function(other) {\n            var otherCollectionType = this._otherCollectionType(other);\n            var thisMapOver = this.mapOver();\n            if (otherCollectionType.isCollection) {\n                if (this.multiple) {\n                    if (this.connected() && !this._collectionAttached()) {\n                        // if single inputs attached, cannot also attach a\n                        // collection (yet...)\n                        return false;\n                    }\n                    if (otherCollectionType.rank == 1) {\n                        return this._producesAcceptableDatatype(other);\n                    } else {\n                        // TODO: Allow subcollection mapping over this as if it were\n                        // a list collection input.\n                        return false;\n                    }\n                }\n                if (\n                    thisMapOver.isCollection &&\n                    thisMapOver.canMatch(otherCollectionType)\n                ) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    //  Need to check if this would break constraints...\n                    var mappingConstraints = this._mappingConstraints();\n                    if (\n                        mappingConstraints.every(\n                            _.bind(\n                                otherCollectionType.canMatch,\n                                otherCollectionType\n                            )\n                        )\n                    ) {\n                        return this._producesAcceptableDatatype(other);\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (thisMapOver.isCollection) {\n                // Attempting to match a non-collection output to an\n                // explicitly collection input.\n                return false;\n            }\n            return this._producesAcceptableDatatype(other);\n        }\n    });\n\n    var InputCollectionTerminal = BaseInputTerminal.extend({\n        update: function(input) {\n            this.multiple = false;\n            this.collection = true;\n            this.datatypes = input.extensions;\n            var collectionTypes = [];\n            if (input.collection_types) {\n                _.each(input.collection_types, function(collectionType) {\n                    collectionTypes.push(\n                        new CollectionTypeDescription(collectionType)\n                    );\n                });\n            } else {\n                collectionTypes.push(ANY_COLLECTION_TYPE_DESCRIPTION);\n            }\n            this.collectionTypes = collectionTypes;\n        },\n        connect: function(connector) {\n            BaseInputTerminal.prototype.connect.call(this, connector);\n            var other = connector.handle1;\n            if (!other) {\n                return;\n            }\n\n            var effectiveMapOver = this._effectiveMapOver(other);\n            this.setMapOver(effectiveMapOver);\n        },\n        _effectiveMapOver: function(other) {\n            var collectionTypes = this.collectionTypes;\n            var otherCollectionType = this._otherCollectionType(other);\n            var canMatch = _.some(collectionTypes, function(collectionType) {\n                return collectionType.canMatch(otherCollectionType);\n            });\n\n            if (!canMatch) {\n                for (var collectionTypeIndex in collectionTypes) {\n                    var collectionType = collectionTypes[collectionTypeIndex];\n                    if (otherCollectionType.canMapOver(collectionType)) {\n                        var effectiveMapOver = otherCollectionType.effectiveMapOver(\n                            collectionType\n                        );\n                        if (\n                            effectiveMapOver != NULL_COLLECTION_TYPE_DESCRIPTION\n                        ) {\n                            return effectiveMapOver;\n                        }\n                    }\n                }\n            }\n            return NULL_COLLECTION_TYPE_DESCRIPTION;\n        },\n        _effectiveCollectionTypes: function() {\n            var thisMapOver = this.mapOver();\n            return _.map(this.collectionTypes, function(t) {\n                return thisMapOver.append(t);\n            });\n        },\n        attachable: function(other) {\n            var otherCollectionType = this._otherCollectionType(other);\n            if (otherCollectionType.isCollection) {\n                var effectiveCollectionTypes = this._effectiveCollectionTypes();\n                var thisMapOver = this.mapOver();\n                var canMatch = _.some(effectiveCollectionTypes, function(\n                    effectiveCollectionType\n                ) {\n                    return effectiveCollectionType.canMatch(\n                        otherCollectionType\n                    );\n                });\n                if (canMatch) {\n                    // Only way a direct match...\n                    return this._producesAcceptableDatatype(other);\n                    // Otherwise we need to mapOver\n                } else if (thisMapOver.isCollection) {\n                    // In this case, mapOver already set and we didn't match skipping...\n                    return false;\n                } else if (\n                    _.some(this.collectionTypes, function(collectionType) {\n                        return otherCollectionType.canMapOver(collectionType);\n                    })\n                ) {\n                    var effectiveMapOver = this._effectiveMapOver(other);\n                    if (!effectiveMapOver.isCollection) {\n                        return false;\n                    }\n                    //  Need to check if this would break constraints...\n                    var mappingConstraints = this._mappingConstraints();\n                    if (mappingConstraints.every(effectiveMapOver.canMatch)) {\n                        return this._producesAcceptableDatatype(other);\n                    }\n                }\n            }\n            return false;\n        }\n    });\n\n    var OutputCollectionTerminal = Terminal.extend({\n        initialize: function(attr) {\n            Terminal.prototype.initialize.call(this, attr);\n            this.datatypes = attr.datatypes;\n            if (attr.collection_type) {\n                this.collectionType = new CollectionTypeDescription(\n                    attr.collection_type\n                );\n            } else {\n                var collectionTypeSource = attr.collection_type_source;\n                if (!collectionTypeSource) {\n                    console.log(\n                        \"Warning: No collection type or collection type source defined.\"\n                    );\n                }\n                this.collectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n            }\n            this.isCollection = true;\n        },\n        update: function(output) {\n            var newCollectionType;\n            if (output.collection_type) {\n                newCollectionType = new CollectionTypeDescription(\n                    output.collection_type\n                );\n            } else {\n                var collectionTypeSource = output.collection_type_source;\n                if (!collectionTypeSource) {\n                    console.log(\n                        \"Warning: No collection type or collection type source defined.\"\n                    );\n                }\n                newCollectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n            }\n\n            if (\n                newCollectionType.collectionType !=\n                this.collectionType.collectionType\n            ) {\n                _.each(this.connectors, function(connector) {\n                    // TODO: consider checking if connection valid before removing...\n                    connector.destroy();\n                });\n            }\n            this.collectionType = newCollectionType;\n        }\n    });\n\n    return {\n        InputTerminal: InputTerminal,\n        OutputTerminal: OutputTerminal,\n        InputCollectionTerminal: InputCollectionTerminal,\n        OutputCollectionTerminal: OutputCollectionTerminal,\n        TerminalMapping: TerminalMapping,\n\n        // test export\n        CollectionTypeDescription: CollectionTypeDescription,\n        NULL_COLLECTION_TYPE_DESCRIPTION: NULL_COLLECTION_TYPE_DESCRIPTION,\n        ANY_COLLECTION_TYPE_DESCRIPTION: ANY_COLLECTION_TYPE_DESCRIPTION\n    };\n});\n"]}