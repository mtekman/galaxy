{"version":3,"sources":["mvc/workflow/workflow-connector.js"],"names":["define","Connector","handle1","handle2","this","canvas","dragging","inner_color","outer_color","$","extend","prototype","connect","t1","t2","destroy","disconnect","destroyIfInvalid","attachable","redraw","canvas_container","document","createElement","style","zIndex","relativeLeft","e","relativeTop","left","offset","top","end_x","element","end_y","canvas_extra","canvas_min_y","Math","min","start_y","canvas_max_y","max","cp_shift","canvas_left","canvas_min_x","canvas_top","canvas_width","canvas_max_x","canvas_height","setAttribute","start_x","start_offsets","end_offsets","num_offsets","isMappedOver","connector","i","outer_width","inner_width","draw_outlined_curve","offset_end","lineCap","strokeStyle","lineWidth","beginPath","bezierCurveTo","length","c","offset_start","getContext","moveTo","stroke"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-connector.js","sourcesContent":["define([], function() {\n    function Connector(handle1, handle2) {\n        this.canvas = null;\n        this.dragging = false;\n        this.inner_color = \"#FFFFFF\";\n        this.outer_color = \"#D8B365\";\n        if (handle1 && handle2) {\n            this.connect(handle1, handle2);\n        }\n    }\n    $.extend(Connector.prototype, {\n        connect: function(t1, t2) {\n            this.handle1 = t1;\n            if (this.handle1) {\n                this.handle1.connect(this);\n            }\n            this.handle2 = t2;\n            if (this.handle2) {\n                this.handle2.connect(this);\n            }\n        },\n        destroy: function() {\n            if (this.handle1) {\n                this.handle1.disconnect(this);\n            }\n            if (this.handle2) {\n                this.handle2.disconnect(this);\n            }\n            $(this.canvas).remove();\n        },\n        destroyIfInvalid: function() {\n            if (\n                this.handle1 &&\n                this.handle2 &&\n                !this.handle2.attachable(this.handle1)\n            ) {\n                this.destroy();\n            }\n        },\n        redraw: function() {\n            var canvas_container = $(\"#canvas-container\");\n            if (!this.canvas) {\n                this.canvas = document.createElement(\"canvas\");\n                canvas_container.append($(this.canvas));\n                if (this.dragging) {\n                    this.canvas.style.zIndex = \"300\";\n                }\n            }\n            var relativeLeft = function(e) {\n                return $(e).offset().left - canvas_container.offset().left;\n            };\n            var relativeTop = function(e) {\n                return $(e).offset().top - canvas_container.offset().top;\n            };\n            if (!this.handle1 || !this.handle2) {\n                return;\n            }\n            // Find the position of each handle\n            var start_x = relativeLeft(this.handle1.element) + 5;\n            var start_y = relativeTop(this.handle1.element) + 5;\n            var end_x = relativeLeft(this.handle2.element) + 5;\n            var end_y = relativeTop(this.handle2.element) + 5;\n            // Calculate canvas area\n            var canvas_extra = 100;\n            var canvas_min_x = Math.min(start_x, end_x);\n            var canvas_max_x = Math.max(start_x, end_x);\n            var canvas_min_y = Math.min(start_y, end_y);\n            var canvas_max_y = Math.max(start_y, end_y);\n            var cp_shift = Math.min(\n                Math.max(Math.abs(canvas_max_y - canvas_min_y) / 2, 100),\n                300\n            );\n            var canvas_left = canvas_min_x - canvas_extra;\n            var canvas_top = canvas_min_y - canvas_extra;\n            var canvas_width = canvas_max_x - canvas_min_x + 2 * canvas_extra;\n            var canvas_height = canvas_max_y - canvas_min_y + 2 * canvas_extra;\n            // Place the canvas\n            this.canvas.style.left = canvas_left + \"px\";\n            this.canvas.style.top = canvas_top + \"px\";\n            this.canvas.setAttribute(\"width\", canvas_width);\n            this.canvas.setAttribute(\"height\", canvas_height);\n            // Adjust points to be relative to the canvas\n            start_x -= canvas_left;\n            start_y -= canvas_top;\n            end_x -= canvas_left;\n            end_y -= canvas_top;\n            // Draw the line\n\n            var c = this.canvas.getContext(\"2d\"),\n                start_offsets = null,\n                end_offsets = null;\n            var num_offsets = 1;\n            if (this.handle1 && this.handle1.isMappedOver()) {\n                var start_offsets = [-6, -3, 0, 3, 6];\n                num_offsets = 5;\n            } else {\n                var start_offsets = [0];\n            }\n            if (this.handle2 && this.handle2.isMappedOver()) {\n                var end_offsets = [-6, -3, 0, 3, 6];\n                num_offsets = 5;\n            } else {\n                var end_offsets = [0];\n            }\n            var connector = this;\n            for (var i = 0; i < num_offsets; i++) {\n                var inner_width = 5,\n                    outer_width = 7;\n                if (start_offsets.length > 1 || end_offsets.length > 1) {\n                    // We have a multi-run, using many lines, make them small.\n                    inner_width = 1;\n                    outer_width = 3;\n                }\n                connector.draw_outlined_curve(\n                    start_x,\n                    start_y,\n                    end_x,\n                    end_y,\n                    cp_shift,\n                    inner_width,\n                    outer_width,\n                    start_offsets[i % start_offsets.length],\n                    end_offsets[i % end_offsets.length]\n                );\n            }\n        },\n        draw_outlined_curve: function(\n            start_x,\n            start_y,\n            end_x,\n            end_y,\n            cp_shift,\n            inner_width,\n            outer_width,\n            offset_start,\n            offset_end\n        ) {\n            var offset_start = offset_start || 0;\n            var offset_end = offset_end || 0;\n            var c = this.canvas.getContext(\"2d\");\n            c.lineCap = \"round\";\n            c.strokeStyle = this.outer_color;\n            c.lineWidth = outer_width;\n            c.beginPath();\n            c.moveTo(start_x, start_y + offset_start);\n            c.bezierCurveTo(\n                start_x + cp_shift,\n                start_y + offset_start,\n                end_x - cp_shift,\n                end_y + offset_end,\n                end_x,\n                end_y + offset_end\n            );\n            c.stroke();\n            // Inner line\n            c.strokeStyle = this.inner_color;\n            c.lineWidth = inner_width;\n            c.beginPath();\n            c.moveTo(start_x, start_y + offset_start);\n            c.bezierCurveTo(\n                start_x + cp_shift,\n                start_y + offset_start,\n                end_x - cp_shift,\n                end_y + offset_end,\n                end_x,\n                end_y + offset_end\n            );\n            c.stroke();\n        }\n    });\n    return Connector;\n});\n"]}