{"version":3,"sources":["mvc/history/history-contents.js"],"names":["define","_super","CONTROLLED_FETCH_COLLECTION","HDA_MODEL","HDCA_MODEL","HISTORY_PREFS","BASE_MVC","AJAX_QUEUE","PaginatedCollection","HistoryContents","HistoryPairDatasetCollection","_logNamespace","model","attrs","options","history_content_type","HistoryDatasetAssociation","console","validationError","collection_type","HistoryListDatasetCollection","limitPerProgressiveFetch","HistoryListPairedDatasetCollection","HistoryListOfListsDatasetCollection","msg","setHistoryId","historyId","includeHidden","limitPerPage","order","urlRoot","Galaxy","url","storage","id","HistoryPrefs","historyStorageKey","initialize","models","prototype","includeDeleted","newVal","this","history","comparators","_","extend","idAttribute","ascending","newId","hid","_setUpWebStorage","initialSettings","filter","trigger","inReadyState","c","get","include-deleted","include-hidden","hasDetails","clone","name","buildComparator","name-dsc","hid-asc","running","runningAndActive","visibleAndUndeleted","getByHid","result","findWhere","haveDetails","all","setIncludeHidden","hidden","deleted","setIncludeDeleted","setting","isBoolean","_fetchParams","_buildFetchFilters","superFilters","filters","purged","getTotalItemCount","details","prefs","toJSON","isEmpty","expandedIds","values","join","fetch","call","visible","_buildFetchData","v","concat","self","defaults","contentsShown","fetchUpdated","detailsFlag","data","remove","update_time-ge","since","toISOString","fetchDeleted","_filterAndUpdate","updateArgs","fetched","currJson","fetchHidden","ajaxQueue","deferred","collection","always","fetchAllDetails","jQuery","Deferred","limit","limitPerCall","searchAttributes","offset","_options","view","keys","detailKeys","reset","response","length","updateWhat","resolve","filterParams","then","_recursivelyFetch","modelArray","i","contentsJSON","copyableModelClasses","json","contentType","ajaxFn","args","type","AjaxQueue","LibraryDatasetDatasetAssociation","HistoryDatasetCollectionAssociation","content","fn","apply","history_id","hide_source_items","element_identifiers","reject","done","notify","allFetched","add","isCopyable","matches","isObject","Collection","model_class","toString","isString","xhr","ajax","method","JSON","stringify","source","parse","fail","error","status","message","createHDCA","elementIdentifiers","collectionType","hideSourceItems","save","haveSearchDetails","has","attributes","matchesWhat","Backbone"],"mappings":"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","file":"../../../scripts/mvc/history/history-contents.js","sourcesContent":["define(\n    [\n        \"mvc/base/controlled-fetch-collection\",\n        \"mvc/history/hda-model\",\n        \"mvc/history/hdca-model\",\n        \"mvc/history/history-preferences\",\n        \"mvc/base-mvc\",\n        \"utils/ajax-queue\"\n    ],\n    function(\n        CONTROLLED_FETCH_COLLECTION,\n        HDA_MODEL,\n        HDCA_MODEL,\n        HISTORY_PREFS,\n        BASE_MVC,\n        AJAX_QUEUE\n    ) {\n        \"use strict\";\n\n        //==============================================================================\n        var _super = CONTROLLED_FETCH_COLLECTION.PaginatedCollection;\n        /** @class Backbone collection for history content.\n *      NOTE: history content seems like a dataset collection, but differs in that it is mixed:\n *          each element can be either an HDA (dataset) or a DatasetCollection and co-exist on\n *          the same level.\n *      Dataset collections on the other hand are not mixed and (so far) can only contain either\n *          HDAs or child dataset collections on one level.\n *      This is why this does not inherit from any of the DatasetCollections (currently).\n */\n        var HistoryContents = _super.extend(BASE_MVC.LoggableMixin).extend({\n            _logNamespace: \"history\",\n\n            // ........................................................................ composite collection\n            /** since history content is a mix, override model fn into a factory, creating based on history_content_type */\n            model: function(attrs, options) {\n                if (attrs.history_content_type === \"dataset\") {\n                    return new HDA_MODEL.HistoryDatasetAssociation(\n                        attrs,\n                        options\n                    );\n                } else if (\n                    attrs.history_content_type === \"dataset_collection\"\n                ) {\n                    switch (attrs.collection_type) {\n                        case \"list\":\n                            return new HDCA_MODEL.HistoryListDatasetCollection(\n                                attrs,\n                                options\n                            );\n                        case \"paired\":\n                            return new HDCA_MODEL.HistoryPairDatasetCollection(\n                                attrs,\n                                options\n                            );\n                        case \"list:paired\":\n                            return new HDCA_MODEL.HistoryListPairedDatasetCollection(\n                                attrs,\n                                options\n                            );\n                        case \"list:list\":\n                            return new HDCA_MODEL.HistoryListOfListsDatasetCollection(\n                                attrs,\n                                options\n                            );\n                    }\n                    // This is a hack inside a hack:\n                    // Raise a plain object with validationError to fake a model.validationError\n                    // (since we don't have a model to use validate with)\n                    // (the outer hack being the mixed content/model function in this collection)\n                    var msg =\n                        \"Unknown collection_type: \" + attrs.collection_type;\n                    console.warn(msg, attrs);\n                    return { validationError: msg };\n                }\n                return {\n                    validationError:\n                        \"Unknown history_content_type: \" +\n                        attrs.history_content_type\n                };\n            },\n\n            // ........................................................................ set up\n            limitPerPage: 500,\n\n            /** @type {Integer} how many contents per call to fetch when using progressivelyFetchDetails */\n            limitPerProgressiveFetch: 500,\n\n            /** @type {String} order used here and when fetching from server */\n            order: \"hid\",\n\n            /** root api url */\n            urlRoot: Galaxy.root + \"api/histories\",\n\n            /** complete api url */\n            url: function() {\n                return this.urlRoot + \"/\" + this.historyId + \"/contents\";\n            },\n\n            /** Set up */\n            initialize: function(models, options) {\n                options = options || {};\n                _super.prototype.initialize.call(this, models, options);\n\n                this.history = options.history || null;\n                this.setHistoryId(options.historyId || null);\n                /** @type {Boolean} does this collection contain and fetch deleted elements */\n                this.includeDeleted =\n                    options.includeDeleted || this.includeDeleted;\n                /** @type {Boolean} does this collection contain and fetch non-visible elements */\n                this.includeHidden =\n                    options.includeHidden || this.includeHidden;\n\n                // backbonejs uses collection.model.prototype.idAttribute to determine if a model is *already* in a collection\n                //  and either merged or replaced. In this case, our 'model' is a function so we need to add idAttribute\n                //  manually here - if we don't, contents will not merge but be replaced/swapped.\n                this.model.prototype.idAttribute = \"type_id\";\n            },\n\n            setHistoryId: function(newId) {\n                this.historyId = newId;\n                this._setUpWebStorage();\n            },\n\n            /** Set up client side storage. Currently PersistanStorage keyed under 'history:<id>' */\n            _setUpWebStorage: function(initialSettings) {\n                // TODO: use initialSettings\n                if (!this.historyId) {\n                    return;\n                }\n                this.storage = new HISTORY_PREFS.HistoryPrefs({\n                    id: HISTORY_PREFS.HistoryPrefs.historyStorageKey(\n                        this.historyId\n                    )\n                });\n                this.trigger(\"new-storage\", this.storage, this);\n\n                this.on({\n                    \"include-deleted\": function(newVal) {\n                        this.storage.includeDeleted(newVal);\n                    },\n                    \"include-hidden\": function(newVal) {\n                        this.storage.includeHidden(newVal);\n                    }\n                });\n\n                this.includeDeleted = this.storage.includeDeleted() || false;\n                this.includeHidden = this.storage.includeHidden() || false;\n                return this;\n            },\n\n            // ........................................................................ common queries\n            /** @type {Object} map of collection available sorting orders containing comparator fns */\n            comparators: _.extend(_.clone(_super.prototype.comparators), {\n                name: BASE_MVC.buildComparator(\"name\", { ascending: true }),\n                \"name-dsc\": BASE_MVC.buildComparator(\"name\", {\n                    ascending: false\n                }),\n                hid: BASE_MVC.buildComparator(\"hid\", { ascending: false }),\n                \"hid-asc\": BASE_MVC.buildComparator(\"hid\", { ascending: true })\n            }),\n\n            /** Get every model in this collection not in a 'ready' state (running). */\n            running: function() {\n                return this.filter(function(c) {\n                    return !c.inReadyState();\n                });\n            },\n\n            /** return contents that are not ready and not deleted/hidden */\n            runningAndActive: function() {\n                return this.filter(function(c) {\n                    return (\n                        !c.inReadyState() &&\n                        c.get(\"visible\") &&\n                        // TODO: deletedOrPurged?\n                        !c.get(\"deleted\")\n                    );\n                });\n            },\n\n            /** Get the model with the given hid\n     *  @param {Int} hid the hid to search for\n     *  @returns {HistoryDatasetAssociation} the model with the given hid or undefined if not found\n     */\n            getByHid: function(hid) {\n                // note: there *can* be more than one content with a given hid, this finds the first based on order\n                return this.findWhere({ hid: hid });\n            },\n\n            /** return true if all contents have details */\n            haveDetails: function() {\n                return this.all(function(c) {\n                    return c.hasDetails();\n                });\n            },\n\n            // ........................................................................ hidden / deleted\n            /** return a new contents collection of only hidden items */\n            hidden: function() {\n                return this.filter(function(c) {\n                    return c.hidden();\n                });\n            },\n\n            /** return a new contents collection of only hidden items */\n            deleted: function() {\n                return this.filter(function(c) {\n                    return c.get(\"deleted\");\n                });\n            },\n\n            /** return a new contents collection of only hidden items */\n            visibleAndUndeleted: function() {\n                return this.filter(function(c) {\n                    return (\n                        c.get(\"visible\") &&\n                        // TODO: deletedOrPurged?\n                        !c.get(\"deleted\")\n                    );\n                });\n            },\n\n            /** create a setter in order to publish the change */\n            setIncludeDeleted: function(setting, options) {\n                if (_.isBoolean(setting) && setting !== this.includeDeleted) {\n                    this.includeDeleted = setting;\n                    if (_.result(options, \"silent\")) {\n                        return;\n                    }\n                    this.trigger(\"include-deleted\", setting, this);\n                }\n            },\n\n            /** create a setter in order to publish the change */\n            setIncludeHidden: function(setting, options) {\n                if (_.isBoolean(setting) && setting !== this.includeHidden) {\n                    this.includeHidden = setting;\n                    options = options || {};\n                    if (_.result(options, \"silent\")) {\n                        return;\n                    }\n                    this.trigger(\"include-hidden\", setting, this);\n                }\n            },\n\n            // ........................................................................ ajax\n            // ............ controlled fetch collection\n            /** override to get expanded ids from sessionStorage and pass to API as details */\n            fetch: function(options) {\n                options = options || {};\n                if (this.historyId && !options.details) {\n                    var prefs = HISTORY_PREFS.HistoryPrefs\n                        .get(this.historyId)\n                        .toJSON();\n                    if (!_.isEmpty(prefs.expandedIds)) {\n                        options.details = _.values(prefs.expandedIds).join(\",\");\n                    }\n                }\n                return _super.prototype.fetch.call(this, options);\n            },\n\n            // ............. ControlledFetch stuff\n            /** override to include the API versioning flag */\n            _buildFetchData: function(options) {\n                return _.extend(\n                    _super.prototype._buildFetchData.call(this, options),\n                    {\n                        v: \"dev\"\n                    }\n                );\n            },\n\n            /** Extend to include details and version */\n            _fetchParams: _super.prototype._fetchParams.concat([\n                // TODO: remove (the need for) both\n                /** version */\n                \"v\",\n                /** dataset ids to get full details of */\n                \"details\"\n            ]),\n\n            /** override to add deleted/hidden filters */\n            _buildFetchFilters: function(options) {\n                var superFilters =\n                    _super.prototype._buildFetchFilters.call(this, options) ||\n                    {};\n                var filters = {};\n                if (!this.includeDeleted) {\n                    filters.deleted = false;\n                    filters.purged = false;\n                }\n                if (!this.includeHidden) {\n                    filters.visible = true;\n                }\n                return _.defaults(superFilters, filters);\n            },\n\n            // ............ paginated collection\n            getTotalItemCount: function() {\n                return this.history.contentsShown();\n            },\n\n            // ............ history contents specific ajax\n            /** override to filter requested contents to those updated after the Date 'since' */\n            fetchUpdated: function(since, options) {\n                if (since) {\n                    options = options || { filters: {} };\n                    options.remove = false;\n                    options.filters = {\n                        \"update_time-ge\": since.toISOString(),\n                        // workflows will produce hidden datasets (non-output datasets) that still\n                        // need to be updated in the collection or they'll update forever\n                        // we can remove the default visible filter by using an 'empty' value\n                        visible: \"\"\n                    };\n                }\n                return this.fetch(options);\n            },\n\n            /** fetch all the deleted==true contents of this collection */\n            fetchDeleted: function(options) {\n                options = options || {};\n                var self = this;\n                options.filters = _.extend(options.filters, {\n                    // all deleted, purged or not\n                    deleted: true,\n                    purged: undefined\n                });\n                options.remove = false;\n\n                self.trigger(\"fetching-deleted\", self);\n                return self.fetch(options).always(function() {\n                    self.trigger(\"fetching-deleted-done\", self);\n                });\n            },\n\n            /** fetch all the visible==false contents of this collection */\n            fetchHidden: function(options) {\n                options = options || {};\n                var self = this;\n                options.filters = _.extend(options.filters, {\n                    visible: false\n                });\n                options.remove = false;\n\n                self.trigger(\"fetching-hidden\", self);\n                return self.fetch(options).always(function() {\n                    self.trigger(\"fetching-hidden-done\", self);\n                });\n            },\n\n            /** fetch detailed model data for all contents in this collection */\n            fetchAllDetails: function(options) {\n                options = options || {};\n                var detailsFlag = { details: \"all\" };\n                options.data = _.extend(options.data || {}, detailsFlag);\n                return this.fetch(options);\n            },\n\n            /** specialty fetch method for retrieving the element_counts of all hdcas in the history */\n            fetchCollectionCounts: function(options) {\n                options = options || {};\n                options.keys = [\"type_id\", \"element_count\"].join(\",\");\n                options.filters = _.extend(options.filters || {}, {\n                    history_content_type: \"dataset_collection\"\n                });\n                options.remove = false;\n                return this.fetch(options);\n            },\n\n            // ............. quasi-batch ops\n            // TODO: to batch\n            /** helper that fetches using filterParams then calls save on each fetched using updateWhat as the save params */\n            _filterAndUpdate: function(filterParams, updateWhat) {\n                var self = this;\n                var idAttribute = self.model.prototype.idAttribute;\n                var updateArgs = [updateWhat];\n\n                return self\n                    .fetch({ filters: filterParams, remove: false })\n                    .then(function(fetched) {\n                        // convert filtered json array to model array\n                        fetched = fetched.reduce(function(\n                            modelArray,\n                            currJson,\n                            i\n                        ) {\n                            var model = self.get(currJson[idAttribute]);\n                            return model\n                                ? modelArray.concat(model)\n                                : modelArray;\n                        },\n                        []);\n                        return self.ajaxQueue(\"save\", updateArgs, fetched);\n                    });\n            },\n\n            /** using a queue, perform ajaxFn on each of the models in this collection */\n            ajaxQueue: function(ajaxFn, args, collection) {\n                collection = collection || this.models;\n                return new AJAX_QUEUE.AjaxQueue(\n                    collection\n                        .slice()\n                        .reverse()\n                        .map(function(content, i) {\n                            var fn = _.isString(ajaxFn)\n                                ? content[ajaxFn]\n                                : ajaxFn;\n                            return function() {\n                                return fn.apply(content, args);\n                            };\n                        })\n                ).deferred;\n            },\n\n            /** fetch contents' details in batches of limitPerCall - note: only get searchable details here */\n            progressivelyFetchDetails: function(options) {\n                options = options || {};\n                var deferred = jQuery.Deferred();\n                var self = this;\n                var limit =\n                    options.limitPerCall || self.limitPerProgressiveFetch;\n                // TODO: only fetch tags and annotations if specifically requested\n                var searchAttributes =\n                    HDA_MODEL.HistoryDatasetAssociation.prototype\n                        .searchAttributes;\n                var detailKeys = searchAttributes.join(\",\");\n\n                function _recursivelyFetch(offset) {\n                    offset = offset || 0;\n                    var _options = _.extend(_.clone(options), {\n                        view: \"summary\",\n                        keys: detailKeys,\n                        limit: limit,\n                        offset: offset,\n                        reset: offset === 0,\n                        remove: false\n                    });\n\n                    _.defer(function() {\n                        self.fetch\n                            .call(self, _options)\n                            .fail(deferred.reject)\n                            .done(function(response) {\n                                deferred.notify(response, limit, offset);\n                                if (response.length !== limit) {\n                                    self.allFetched = true;\n                                    deferred.resolve(response, limit, offset);\n                                } else {\n                                    _recursivelyFetch(offset + limit);\n                                }\n                            });\n                    });\n                }\n                _recursivelyFetch();\n                return deferred;\n            },\n\n            /** does some bit of JSON represent something that can be copied into this contents collection */\n            isCopyable: function(contentsJSON) {\n                var copyableModelClasses = [\n                    \"HistoryDatasetAssociation\",\n                    \"HistoryDatasetCollectionAssociation\"\n                ];\n                return (\n                    _.isObject(contentsJSON) &&\n                    contentsJSON.id &&\n                    _.contains(copyableModelClasses, contentsJSON.model_class)\n                );\n            },\n\n            /** copy an existing, accessible hda into this collection */\n            copy: function(json) {\n                // TODO: somehow showhorn all this into 'save'\n                var id, type, contentType;\n                if (_.isString(json)) {\n                    id = json;\n                    contentType = \"hda\";\n                    type = \"dataset\";\n                } else {\n                    id = json.id;\n                    contentType =\n                        {\n                            HistoryDatasetAssociation: \"hda\",\n                            LibraryDatasetDatasetAssociation: \"ldda\",\n                            HistoryDatasetCollectionAssociation: \"hdca\"\n                        }[json.model_class] || \"hda\";\n                    type =\n                        contentType === \"hdca\"\n                            ? \"dataset_collection\"\n                            : \"dataset\";\n                }\n                var collection = this,\n                    xhr = jQuery\n                        .ajax(this.url(), {\n                            method: \"POST\",\n                            contentType: \"application/json\",\n                            data: JSON.stringify({\n                                content: id,\n                                source: contentType,\n                                type: type\n                            })\n                        })\n                        .done(function(response) {\n                            collection.add([response], { parse: true });\n                        })\n                        .fail(function(error, status, message) {\n                            collection.trigger(\n                                \"error\",\n                                collection,\n                                xhr,\n                                {},\n                                \"Error copying contents\",\n                                { type: type, id: id, source: contentType }\n                            );\n                        });\n                return xhr;\n            },\n\n            /** create a new HDCA in this collection */\n            createHDCA: function(\n                elementIdentifiers,\n                collectionType,\n                name,\n                hideSourceItems,\n                options\n            ) {\n                // normally collection.create returns the new model, but we need the promise from the ajax, so we fake create\n                //precondition: elementIdentifiers is an array of plain js objects\n                //  in the proper form to create the collectionType\n                var hdca = this.model({\n                    history_content_type: \"dataset_collection\",\n                    collection_type: collectionType,\n                    history_id: this.historyId,\n                    name: name,\n                    hide_source_items: hideSourceItems || false,\n                    // should probably be able to just send in a bunch of json here and restruct per class\n                    // note: element_identifiers is now (incorrectly) an attribute\n                    element_identifiers: elementIdentifiers\n                    // do not create the model on the client until the ajax returns\n                });\n                return hdca.save(options);\n            },\n\n            // ........................................................................ searching\n            /** return true if all contents have the searchable attributes */\n            haveSearchDetails: function() {\n                return (\n                    this.allFetched &&\n                    this.all(function(content) {\n                        // null (which is a valid returned annotation value)\n                        // will return false when using content.has( 'annotation' )\n                        //TODO: a bit hacky - formalize\n                        return _.has(content.attributes, \"annotation\");\n                    })\n                );\n            },\n\n            /** return a new collection of contents whose attributes contain the substring matchesWhat */\n            matches: function(matchesWhat) {\n                return this.filter(function(content) {\n                    return content.matches(matchesWhat);\n                });\n            },\n\n            // ........................................................................ misc\n            /** In this override, copy the historyId to the clone */\n            clone: function() {\n                var clone = Backbone.Collection.prototype.clone.call(this);\n                clone.historyId = this.historyId;\n                return clone;\n            },\n\n            /** String representation. */\n            toString: function() {\n                return [\n                    \"HistoryContents(\",\n                    [this.historyId, this.length].join(),\n                    \")\"\n                ].join(\"\");\n            }\n        });\n\n        //==============================================================================\n        return {\n            HistoryContents: HistoryContents\n        };\n    }\n);\n"]}