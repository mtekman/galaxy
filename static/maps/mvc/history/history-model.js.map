{"version":3,"sources":["mvc/history/history-model.js"],"names":["define","HISTORY_CONTENTS","HISTORY_PREFS","History","UTILS","_logNamespace","_l","Backbone","Model","extend","BASE_MVC","LoggableMixin","deleted","mixin","contents_active","UPDATE_DELAY","defaults","searchAttributes","id","name","state","contents_states","urlRoot","Galaxy","root","contentsClass","HistoryContents","logger","searchAliases","contents","history","initialize","historyJSON","options","updateTimeoutId","this","log","historyId","get","order","_setUpListeners","_setUpCollectionListeners","on","error","model","xhr","msg","details","clearUpdateTimeout","change:id","newId","apply","contentsActive","listenTo","trigger","jQuery","makeArray","arguments","includeDeleted","contentsShown","shown","active","nice_size","includeHidden","hidden","size","ownedByCurrUser","bytesToString","isAnonymous","_","prototype","toJSON","call","key","runningAndActive","length","user","numOfUnfinishedJobs","fetchUpdated","unfinishedJobIds","serverResponseDatetime","Date","_fetchContentRelatedAttributes","contentRelatedAttrs","fetch","data","$","param","keys","join","self","nonReadyContentCount","numOfUnfinishedShownContents","currentPage","fetchPage","_delayThenUpdate","lastUpdateTime","done","response","status","getResponseHeader","err","clearTimeout","checkForUpdates","setTimeout","refresh","delay","create_time","update_time","historyData","parse","save","purged","parsed","fetchWithContents","allDatasets","contentsOptions","current","undefined","history_id","then","all_datasets","setHistoryId","fetchContents","copy","newHistory","setAsCurrent","fetchCurrentPage","when","undelete","Error","postData","models","view","post","setUpListeners","remove","setCurrent","getJSON","oldCurrentId","toString","superFilters","_collectionSuper","CONTROLLED_FETCH_COLLECTION","HistoryCollection","currentHistoryId","silent","filters","limitPerFetch","offset","comparators","ascending","buildComparator","currentHistory","collection","original","newData","set-as-current","_buildFetchData","_buildFetchFilters","fetchFirst","limit","encoded_id-in","fetchMore","clone","name-dsc","size-asc","sort","unshift","create","hdas","historyOptions","xhrOptions"],"mappings":"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","file":"../../../scripts/mvc/history/history-model.js","sourcesContent":["define(\n    [\n        \"mvc/history/history-contents\",\n        \"mvc/history/history-preferences\",\n        \"mvc/base/controlled-fetch-collection\",\n        \"utils/utils\",\n        \"mvc/base-mvc\",\n        \"utils/localization\"\n    ],\n    function(\n        HISTORY_CONTENTS,\n        HISTORY_PREFS,\n        CONTROLLED_FETCH_COLLECTION,\n        UTILS,\n        BASE_MVC,\n        _l\n    ) {\n        \"use strict\";\n\n        //==============================================================================\n        /** @class Model for a Galaxy history resource - both a record of user\n *      tool use and a collection of the datasets those tools produced.\n *  @name History\n *  @augments Backbone.Model\n */\n        var History = Backbone.Model.extend(BASE_MVC.LoggableMixin).extend(\n            BASE_MVC.mixin(\n                BASE_MVC.SearchableModelMixin,\n                /** @lends History.prototype */ {\n                    _logNamespace: \"history\",\n\n                    /** ms between fetches when checking running jobs/datasets for updates */\n                    UPDATE_DELAY: 4000,\n\n                    // values from api (may need more)\n                    defaults: {\n                        model_class: \"History\",\n                        id: null,\n                        name: \"Unnamed History\",\n                        state: \"new\",\n\n                        deleted: false,\n                        contents_active: {},\n                        contents_states: {}\n                    },\n\n                    urlRoot: Galaxy.root + \"api/histories\",\n\n                    contentsClass: HISTORY_CONTENTS.HistoryContents,\n\n                    /** What model fields to search with */\n                    searchAttributes: [\"name\", \"annotation\", \"tags\"],\n\n                    /** Adding title and singular tag */\n                    searchAliases: {\n                        title: \"name\",\n                        tag: \"tags\"\n                    },\n\n                    // ........................................................................ set up/tear down\n                    /** Set up the model\n     *  @param {Object} historyJSON model data for this History\n     *  @param {Object} options     any extra settings including logger\n     */\n                    initialize: function(historyJSON, options) {\n                        options = options || {};\n                        this.logger = options.logger || null;\n                        this.log(this + \".initialize:\", historyJSON, options);\n\n                        /** HistoryContents collection of the HDAs contained in this history. */\n                        this.contents = new this.contentsClass([], {\n                            history: this,\n                            historyId: this.get(\"id\"),\n                            order: options.order\n                        });\n\n                        this._setUpListeners();\n                        this._setUpCollectionListeners();\n\n                        /** cached timeout id for the dataset updater */\n                        this.updateTimeoutId = null;\n                    },\n\n                    /** set up any event listeners for this history including those to the contained HDAs\n     *  events: error:contents  if an error occurred with the contents collection\n     */\n                    _setUpListeners: function() {\n                        // if the model's id changes ('current' or null -> an actual id), update the contents history_id\n                        return this.on({\n                            error: function(model, xhr, options, msg, details) {\n                                this.clearUpdateTimeout();\n                            },\n                            \"change:id\": function(model, newId) {\n                                if (this.contents) {\n                                    this.contents.historyId = newId;\n                                }\n                            }\n                        });\n                    },\n\n                    /** event handlers for the contents submodels */\n                    _setUpCollectionListeners: function() {\n                        if (!this.contents) {\n                            return this;\n                        }\n                        // bubble up errors\n                        return this.listenTo(this.contents, {\n                            error: function() {\n                                this.trigger.apply(\n                                    this,\n                                    jQuery.makeArray(arguments)\n                                );\n                            }\n                        });\n                    },\n\n                    // ........................................................................ derived attributes\n                    /**  */\n                    contentsShown: function() {\n                        var contentsActive = this.get(\"contents_active\");\n                        var shown = contentsActive.active || 0;\n                        shown += this.contents.includeDeleted\n                            ? contentsActive.deleted\n                            : 0;\n                        shown += this.contents.includeHidden\n                            ? contentsActive.hidden\n                            : 0;\n                        return shown;\n                    },\n\n                    /** convert size in bytes to a more human readable version */\n                    nice_size: function() {\n                        var size = this.get(\"size\");\n                        return size\n                            ? UTILS.bytesToString(size, true, 2)\n                            : _l(\"(empty)\");\n                    },\n\n                    /** override to add nice_size */\n                    toJSON: function() {\n                        return _.extend(\n                            Backbone.Model.prototype.toJSON.call(this),\n                            {\n                                nice_size: this.nice_size()\n                            }\n                        );\n                    },\n\n                    /** override to allow getting nice_size */\n                    get: function(key) {\n                        if (key === \"nice_size\") {\n                            return this.nice_size();\n                        }\n                        return Backbone.Model.prototype.get.apply(\n                            this,\n                            arguments\n                        );\n                    },\n\n                    // ........................................................................ common queries\n                    /** T/F is this history owned by the current user (Galaxy.user)\n     *      Note: that this will return false for an anon user even if the history is theirs.\n     */\n                    ownedByCurrUser: function() {\n                        // no currUser\n                        if (!Galaxy || !Galaxy.user) {\n                            return false;\n                        }\n                        // user is anon or history isn't owned\n                        if (\n                            Galaxy.user.isAnonymous() ||\n                            Galaxy.user.id !== this.get(\"user_id\")\n                        ) {\n                            return false;\n                        }\n                        return true;\n                    },\n\n                    /** Return the number of running jobs assoc with this history (note: unknown === 0) */\n                    numOfUnfinishedJobs: function() {\n                        var unfinishedJobIds = this.get(\"non_ready_jobs\");\n                        return unfinishedJobIds ? unfinishedJobIds.length : 0;\n                    },\n\n                    /** Return the number of running hda/hdcas in this history (note: unknown === 0) */\n                    numOfUnfinishedShownContents: function() {\n                        return this.contents.runningAndActive().length || 0;\n                    },\n\n                    // ........................................................................ updates\n                    _fetchContentRelatedAttributes: function() {\n                        var contentRelatedAttrs = [\n                            \"size\",\n                            \"non_ready_jobs\",\n                            \"contents_active\",\n                            \"hid_counter\"\n                        ];\n                        return this.fetch({\n                            data: $.param({\n                                keys: contentRelatedAttrs.join(\",\")\n                            })\n                        });\n                    },\n\n                    /** check for any changes since the last time we updated (or fetch all if ) */\n                    refresh: function(options) {\n                        // console.log( this + '.refresh' );\n                        options = options || {};\n                        var self = this;\n\n                        // note if there was no previous update time, all summary contents will be fetched\n                        var lastUpdateTime = self.lastUpdateTime;\n                        // if we don't flip this, then a fully-fetched list will not be re-checked via fetch\n                        this.contents.allFetched = false;\n                        var fetchFn =\n                            self.contents.currentPage !== 0\n                                ? function() {\n                                      return self.contents.fetchPage(\n                                          self.contents.currentPage\n                                      );\n                                  }\n                                : function() {\n                                      return self.contents.fetchUpdated(\n                                          lastUpdateTime\n                                      );\n                                  };\n                        // note: if there was no previous update time, all summary contents will be fetched\n                        return fetchFn().done(function(response, status, xhr) {\n                            var serverResponseDatetime;\n                            try {\n                                serverResponseDatetime = new Date(\n                                    xhr.getResponseHeader(\"Date\")\n                                );\n                            } catch (err) {}\n                            self.lastUpdateTime =\n                                serverResponseDatetime || new Date();\n                            self.checkForUpdates(options);\n                        });\n                    },\n\n                    /** continuously fetch updated contents every UPDATE_DELAY ms if this history's datasets or jobs are unfinished */\n                    checkForUpdates: function(options) {\n                        // console.log( this + '.checkForUpdates' );\n                        options = options || {};\n                        var delay = this.UPDATE_DELAY;\n                        var self = this;\n                        if (!self.id) {\n                            return;\n                        }\n\n                        function _delayThenUpdate() {\n                            // prevent buildup of updater timeouts by clearing previous if any, then set new and cache id\n                            self.clearUpdateTimeout();\n                            self.updateTimeoutId = setTimeout(function() {\n                                self.refresh(options);\n                            }, delay);\n                        }\n\n                        // if there are still datasets in the non-ready state, recurse into this function with the new time\n                        var nonReadyContentCount = this.numOfUnfinishedShownContents();\n                        // console.log( 'nonReadyContentCount:', nonReadyContentCount );\n                        if (nonReadyContentCount > 0) {\n                            _delayThenUpdate();\n                        } else {\n                            // no datasets are running, but currently runnning jobs may still produce new datasets\n                            // see if the history has any running jobs and continue to update if so\n                            // (also update the size for the user in either case)\n                            self\n                                ._fetchContentRelatedAttributes()\n                                .done(function(historyData) {\n                                    // console.log( 'non_ready_jobs:', historyData.non_ready_jobs );\n                                    if (self.numOfUnfinishedJobs() > 0) {\n                                        _delayThenUpdate();\n                                    } else {\n                                        // otherwise, let listeners know that all updates have stopped\n                                        self.trigger(\"ready\");\n                                    }\n                                });\n                        }\n                    },\n\n                    /** clear the timeout and the cached timeout id */\n                    clearUpdateTimeout: function() {\n                        if (this.updateTimeoutId) {\n                            clearTimeout(this.updateTimeoutId);\n                            this.updateTimeoutId = null;\n                        }\n                    },\n\n                    // ........................................................................ ajax\n                    /** override to use actual Dates objects for create/update times */\n                    parse: function(response, options) {\n                        var parsed = Backbone.Model.prototype.parse.call(\n                            this,\n                            response,\n                            options\n                        );\n                        if (parsed.create_time) {\n                            parsed.create_time = new Date(parsed.create_time);\n                        }\n                        if (parsed.update_time) {\n                            parsed.update_time = new Date(parsed.update_time);\n                        }\n                        return parsed;\n                    },\n\n                    /** fetch this histories data (using options) then it's contents (using contentsOptions) */\n                    fetchWithContents: function(options, contentsOptions) {\n                        options = options || {};\n                        var self = this;\n\n                        // console.log( this + '.fetchWithContents' );\n                        // TODO: push down to a base class\n                        options.view = \"dev-detailed\";\n\n                        // fetch history then use history data to fetch (paginated) contents\n                        return this.fetch(options).then(function getContents(\n                            history\n                        ) {\n                            self.contents.history = self;\n                            self.contents.setHistoryId(history.id);\n                            return self.fetchContents(contentsOptions);\n                        });\n                    },\n\n                    /** fetch this histories contents, adjusting options based on the stored history preferences */\n                    fetchContents: function(options) {\n                        options = options || {};\n                        var self = this;\n\n                        // we're updating, reset the update time\n                        self.lastUpdateTime = new Date();\n                        return self.contents.fetchCurrentPage(options);\n                    },\n\n                    /** save this history, _Mark_ing it as deleted (just a flag) */\n                    _delete: function(options) {\n                        if (this.get(\"deleted\")) {\n                            return jQuery.when();\n                        }\n                        return this.save({ deleted: true }, options);\n                    },\n                    /** purge this history, _Mark_ing it as purged and removing all dataset data from the server */\n                    purge: function(options) {\n                        if (this.get(\"purged\")) {\n                            return jQuery.when();\n                        }\n                        return this.save(\n                            { deleted: true, purged: true },\n                            options\n                        );\n                    },\n                    /** save this history, _Mark_ing it as undeleted */\n                    undelete: function(options) {\n                        if (!this.get(\"deleted\")) {\n                            return jQuery.when();\n                        }\n                        return this.save({ deleted: false }, options);\n                    },\n\n                    /** Make a copy of this history on the server\n     *  @param {Boolean} current    if true, set the copy as the new current history (default: true)\n     *  @param {String} name        name of new history (default: none - server sets to: Copy of <current name>)\n     *  @fires copied               passed this history and the response JSON from the copy\n     *  @returns {xhr}\n     */\n                    copy: function(current, name, allDatasets) {\n                        current = current !== undefined ? current : true;\n                        if (!this.id) {\n                            throw new Error(\n                                \"You must set the history ID before copying it.\"\n                            );\n                        }\n\n                        var postData = { history_id: this.id };\n                        if (current) {\n                            postData.current = true;\n                        }\n                        if (name) {\n                            postData.name = name;\n                        }\n                        if (!allDatasets) {\n                            postData.all_datasets = false;\n                        }\n                        postData.view = \"dev-detailed\";\n\n                        var history = this;\n                        var copy = jQuery.post(this.urlRoot, postData);\n                        // if current - queue to setAsCurrent before firing 'copied'\n                        if (current) {\n                            return copy.then(function(response) {\n                                var newHistory = new History(response);\n                                return newHistory\n                                    .setAsCurrent()\n                                    .done(function() {\n                                        history.trigger(\n                                            \"copied\",\n                                            history,\n                                            response\n                                        );\n                                    });\n                            });\n                        }\n                        return copy.done(function(response) {\n                            history.trigger(\"copied\", history, response);\n                        });\n                    },\n\n                    setAsCurrent: function() {\n                        var history = this,\n                            xhr = jQuery.getJSON(\n                                Galaxy.root +\n                                    \"history/set_as_current?id=\" +\n                                    this.id\n                            );\n\n                        xhr.done(function() {\n                            history.trigger(\"set-as-current\", history);\n                        });\n                        return xhr;\n                    },\n\n                    // ........................................................................ misc\n                    toString: function() {\n                        return (\n                            \"History(\" +\n                            this.get(\"id\") +\n                            \",\" +\n                            this.get(\"name\") +\n                            \")\"\n                        );\n                    }\n                }\n            )\n        );\n\n        //==============================================================================\n        var _collectionSuper =\n            CONTROLLED_FETCH_COLLECTION.InfinitelyScrollingCollection;\n        /** @class A collection of histories (per user)\n *      that maintains the current history as the first in the collection.\n *  New or copied histories become the current history.\n */\n        var HistoryCollection = _collectionSuper\n            .extend(BASE_MVC.LoggableMixin)\n            .extend({\n                _logNamespace: \"history\",\n\n                model: History,\n                /** @type {String} initial order used by collection */\n                order: \"update_time\",\n                /** @type {Number} limit used for the first fetch (or a reset) */\n                limitOnFirstFetch: 10,\n                /** @type {Number} limit used for each subsequent fetch */\n                limitPerFetch: 10,\n\n                initialize: function(models, options) {\n                    options = options || {};\n                    this.log(\"HistoryCollection.initialize\", models, options);\n                    _collectionSuper.prototype.initialize.call(\n                        this,\n                        models,\n                        options\n                    );\n\n                    /** @type {boolean} should deleted histories be included */\n                    this.includeDeleted = options.includeDeleted || false;\n\n                    /** @type {String} encoded id of the history that's current */\n                    this.currentHistoryId = options.currentHistoryId;\n\n                    this.setUpListeners();\n                    // note: models are sent to reset *after* this fn ends; up to this point\n                    // the collection *is empty*\n                },\n\n                urlRoot: Galaxy.root + \"api/histories\",\n                url: function() {\n                    return this.urlRoot;\n                },\n\n                /** set up reflexive event handlers */\n                setUpListeners: function setUpListeners() {\n                    return this.on({\n                        // when a history is deleted, remove it from the collection (if optionally set to do so)\n                        \"change:deleted\": function(history) {\n                            // TODO: this becomes complicated when more filters are used\n                            this.debug(\n                                \"change:deleted\",\n                                this.includeDeleted,\n                                history.get(\"deleted\")\n                            );\n                            if (\n                                !this.includeDeleted &&\n                                history.get(\"deleted\")\n                            ) {\n                                this.remove(history);\n                            }\n                        },\n                        // listen for a history copy, setting it to current\n                        copied: function(original, newData) {\n                            this.setCurrent(new History(newData, []));\n                        },\n                        // when a history is made current, track the id in the collection\n                        \"set-as-current\": function(history) {\n                            var oldCurrentId = this.currentHistoryId;\n                            this.trigger(\"no-longer-current\", oldCurrentId);\n                            this.currentHistoryId = history.id;\n                        }\n                    });\n                },\n\n                /** override to change view */\n                _buildFetchData: function(options) {\n                    return _.extend(\n                        _collectionSuper.prototype._buildFetchData.call(\n                            this,\n                            options\n                        ),\n                        {\n                            view: \"dev-detailed\"\n                        }\n                    );\n                },\n\n                /** override to filter out deleted and purged */\n                _buildFetchFilters: function(options) {\n                    var superFilters =\n                        _collectionSuper.prototype._buildFetchFilters.call(\n                            this,\n                            options\n                        ) || {};\n                    var filters = {};\n                    if (!this.includeDeleted) {\n                        filters.deleted = false;\n                        filters.purged = false;\n                    } else {\n                        // force API to return both deleted and non\n                        //TODO: when the API is updated, remove this\n                        filters.deleted = null;\n                    }\n                    return _.defaults(superFilters, filters);\n                },\n\n                /** override to fetch current as well (as it may be outside the first 10, etc.) */\n                fetchFirst: function(options) {\n                    var self = this;\n                    // TODO: batch?\n                    var xhr = $.when();\n                    if (this.currentHistoryId) {\n                        xhr = _collectionSuper.prototype.fetchFirst.call(self, {\n                            silent: true,\n                            limit: 1,\n                            filters: {\n                                // without these a deleted current history will return [] here and block the other xhr\n                                purged: \"\",\n                                deleted: \"\",\n                                \"encoded_id-in\": this.currentHistoryId\n                            }\n                        });\n                    }\n                    return xhr.then(function() {\n                        options = options || {};\n                        options.offset = 0;\n                        return self.fetchMore(options);\n                    });\n                },\n\n                /** @type {Object} map of collection available sorting orders containing comparator fns */\n                comparators: _.extend(\n                    _.clone(_collectionSuper.prototype.comparators),\n                    {\n                        name: BASE_MVC.buildComparator(\"name\", {\n                            ascending: true\n                        }),\n                        \"name-dsc\": BASE_MVC.buildComparator(\"name\", {\n                            ascending: false\n                        }),\n                        size: BASE_MVC.buildComparator(\"size\", {\n                            ascending: false\n                        }),\n                        \"size-asc\": BASE_MVC.buildComparator(\"size\", {\n                            ascending: true\n                        })\n                    }\n                ),\n\n                /** override to always have the current history first */\n                sort: function(options) {\n                    options = options || {};\n                    var silent = options.silent;\n                    var currentHistory = this.remove(\n                        this.get(this.currentHistoryId)\n                    );\n                    _collectionSuper.prototype.sort.call(\n                        this,\n                        _.defaults({ silent: true }, options)\n                    );\n                    this.unshift(currentHistory, { silent: true });\n                    if (!silent) {\n                        this.trigger(\"sort\", this, options);\n                    }\n                    return this;\n                },\n\n                /** create a new history and by default set it to be the current history */\n                create: function create(\n                    data,\n                    hdas,\n                    historyOptions,\n                    xhrOptions\n                ) {\n                    //TODO: .create is actually a collection function that's overridden here\n                    var collection = this,\n                        xhr = jQuery.getJSON(\n                            Galaxy.root + \"history/create_new_current\"\n                        );\n                    return xhr.done(function(newData) {\n                        collection.setCurrent(\n                            new History(newData, [], historyOptions || {})\n                        );\n                    });\n                },\n\n                /** set the current history to the given history, placing it first in the collection.\n     *  Pass standard bbone options for use in unshift.\n     *  @triggers new-current passed history and this collection\n     */\n                setCurrent: function(history, options) {\n                    options = options || {};\n                    // new histories go in the front\n                    this.unshift(history, options);\n                    this.currentHistoryId = history.get(\"id\");\n                    if (!options.silent) {\n                        this.trigger(\"new-current\", history, this);\n                    }\n                    return this;\n                },\n\n                toString: function toString() {\n                    return (\n                        \"HistoryCollection(\" +\n                        this.length +\n                        \",current:\" +\n                        this.currentHistoryId +\n                        \")\"\n                    );\n                }\n            });\n\n        //==============================================================================\n        return {\n            History: History,\n            HistoryCollection: HistoryCollection\n        };\n    }\n);\n"]}