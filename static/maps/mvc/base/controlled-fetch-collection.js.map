{"version":3,"sources":["mvc/base/controlled-fetch-collection.js"],"names":["define","_","BASE_MVC","ControlledFetchCollection","Backbone","Collection","extend","prototype","setOrder","options","initialize","call","this","models","order","silent","_setUpListeners","on","changed-order","sort","fetch","_buildFetchOptions","self","clone","traditional","Galaxy","debug","data","filters","_buildFetchData","isEmpty","_buildFetchFilters","_fetchFiltersToAjaxData","defaults","pick","_fetchParams","filterMap","q","qv","each","v","k","undefined","push","allFetched","reset","comparators","update_time","ascending","create_time","buildComparator","update_time-asc","create_time-asc","comparator","collection","isUndefined","limitPerPage","PaginatedCollection","getTotalItemCount","getLastPage","currentPage","length","shouldPaginate","limit","Math","floor","getPageCount","getPageLimitOffset","pageNum","constrainPageNum","offset","max","min","fetchPage","fetchPrevPage","fetchNextPage","trigger","always","InfinitelyScrollingCollection","limitPerFetch","limitOnFirstFetch","fetchFirst","lastFetched","remove","fetchMore","jQuery","when","numFetched","isArray","fetchedData","fetchAll","done"],"mappings":"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","file":"../../../scripts/mvc/base/controlled-fetch-collection.js","sourcesContent":["define([\"libs/underscore\", \"libs/backbone\", \"mvc/base-mvc\"], function(\n    _,\n    Backbone,\n    BASE_MVC\n) {\n    \"use strict\";\n\n    //=============================================================================\n    /**\n * A Collection that can be limited/offset/re-ordered/filtered.\n * @type {Backbone.Collection}\n */\n    var ControlledFetchCollection = Backbone.Collection.extend({\n        /** call setOrder on initialization to build the comparator based on options */\n        initialize: function(models, options) {\n            Backbone.Collection.prototype.initialize.call(\n                this,\n                models,\n                options\n            );\n            this.setOrder(options.order || this.order, { silent: true });\n        },\n\n        /** set up to track order changes and re-sort when changed */\n        _setUpListeners: function() {\n            return this.on({\n                \"changed-order\": this.sort\n            });\n        },\n\n        /** override to provide order and offsets based on instance vars, set limit if passed,\n     *  and set allFetched/fire 'all-fetched' when xhr returns\n     */\n        fetch: function(options) {\n            options = this._buildFetchOptions(options);\n            Galaxy.debug(\"fetch options:\", options);\n            return Backbone.Collection.prototype.fetch.call(this, options);\n        },\n\n        /** build ajax data/parameters from options */\n        _buildFetchOptions: function(options) {\n            // note: we normally want options passed in to override the defaults built here\n            // so most of these fns will generate defaults\n            options = _.clone(options) || {};\n            var self = this;\n\n            // jquery ajax option; allows multiple q/qv for filters (instead of 'q[]')\n            options.traditional = true;\n\n            // options.data\n            // we keep limit, offset, etc. in options *as well as move it into data* because:\n            // - it makes fetch calling convenient to add it to a single options map (instead of as mult. args)\n            // - it allows the std. event handlers (for fetch, etc.) to have access\n            //   to the pagination options too\n            //      (i.e. this.on( 'sync', function( options ){ if( options.limit ){ ... } }))\n            // however, when we send to xhr/jquery we copy them to data also so that they become API query params\n            options.data = options.data || self._buildFetchData(options);\n            Galaxy.debug(\"data:\", options.data);\n\n            // options.data.filters --> options.data.q, options.data.qv\n            var filters = this._buildFetchFilters(options);\n            Galaxy.debug(\"filters:\", filters);\n            if (!_.isEmpty(filters)) {\n                _.extend(options.data, this._fetchFiltersToAjaxData(filters));\n            }\n            Galaxy.debug(\"data:\", options.data);\n            return options;\n        },\n\n        /** Build the dictionary to send to fetch's XHR as data */\n        _buildFetchData: function(options) {\n            var defaults = {};\n            if (this.order) {\n                defaults.order = this.order;\n            }\n            return _.defaults(_.pick(options, this._fetchParams), defaults);\n        },\n\n        /** These attribute keys are valid params to fetch/API-index */\n        _fetchParams: [\n            /** model dependent string to control the order of models returned */\n            \"order\",\n            /** limit the number of models returned from a fetch */\n            \"limit\",\n            /** skip this number of models when fetching */\n            \"offset\",\n            /** what series of attributes to return (model dependent) */\n            \"view\",\n            /** individual keys to return for the models (see api/histories.index) */\n            \"keys\"\n        ],\n\n        /** add any needed filters here based on collection state */\n        _buildFetchFilters: function(options) {\n            // override\n            return _.clone(options.filters || {});\n        },\n\n        /** Convert dictionary filters to qqv style arrays */\n        _fetchFiltersToAjaxData: function(filters) {\n            // return as a map so ajax.data can extend from it\n            var filterMap = {\n                q: [],\n                qv: []\n            };\n            _.each(filters, function(v, k) {\n                // don't send if filter value is empty\n                if (v === undefined || v === \"\") {\n                    return;\n                }\n                // json to python\n                if (v === true) {\n                    v = \"True\";\n                }\n                if (v === false) {\n                    v = \"False\";\n                }\n                if (v === null) {\n                    v = \"None\";\n                }\n                // map to k/v arrays (q/qv)\n                filterMap.q.push(k);\n                filterMap.qv.push(v);\n            });\n            return filterMap;\n        },\n\n        /** override to reset allFetched flag to false */\n        reset: function(models, options) {\n            this.allFetched = false;\n            return Backbone.Collection.prototype.reset.call(\n                this,\n                models,\n                options\n            );\n        },\n\n        // ........................................................................ order\n        order: null,\n\n        /** @type {Object} map of collection available sorting orders containing comparator fns */\n        comparators: {\n            update_time: BASE_MVC.buildComparator(\"update_time\", {\n                ascending: false\n            }),\n            \"update_time-asc\": BASE_MVC.buildComparator(\"update_time\", {\n                ascending: true\n            }),\n            create_time: BASE_MVC.buildComparator(\"create_time\", {\n                ascending: false\n            }),\n            \"create_time-asc\": BASE_MVC.buildComparator(\"create_time\", {\n                ascending: true\n            })\n        },\n\n        /** set the order and comparator for this collection then sort with the new order\n     *  @event 'changed-order' passed the new order and the collection\n     */\n        setOrder: function(order, options) {\n            options = options || {};\n            var collection = this;\n            var comparator = collection.comparators[order];\n            if (_.isUndefined(comparator)) {\n                throw new Error(\"unknown order: \" + order);\n            }\n            // if( _.isUndefined( comparator ) ){ return; }\n            if (comparator === collection.comparator) {\n                return;\n            }\n\n            collection.order = order;\n            collection.comparator = comparator;\n\n            if (!options.silent) {\n                collection.trigger(\"changed-order\", options);\n            }\n            return collection;\n        }\n    });\n\n    //=============================================================================\n    /**\n *\n */\n    var PaginatedCollection = ControlledFetchCollection.extend({\n        /** @type {Number} limit used for each page's fetch */\n        limitPerPage: 500,\n\n        initialize: function(models, options) {\n            ControlledFetchCollection.prototype.initialize.call(\n                this,\n                models,\n                options\n            );\n            this.currentPage = options.currentPage || 0;\n        },\n\n        getTotalItemCount: function() {\n            return this.length;\n        },\n\n        shouldPaginate: function() {\n            return this.getTotalItemCount() >= this.limitPerPage;\n        },\n\n        getLastPage: function() {\n            return Math.floor(this.getTotalItemCount() / this.limitPerPage);\n        },\n\n        getPageCount: function() {\n            return this.getLastPage() + 1;\n        },\n\n        getPageLimitOffset: function(pageNum) {\n            pageNum = this.constrainPageNum(pageNum);\n            return {\n                limit: this.limitPerPage,\n                offset: pageNum * this.limitPerPage\n            };\n        },\n\n        constrainPageNum: function(pageNum) {\n            return Math.max(0, Math.min(pageNum, this.getLastPage()));\n        },\n\n        /** fetch the next page of data */\n        fetchPage: function(pageNum, options) {\n            var self = this;\n            pageNum = self.constrainPageNum(pageNum);\n            self.currentPage = pageNum;\n            options = _.defaults(\n                options || {},\n                self.getPageLimitOffset(pageNum)\n            );\n\n            self.trigger(\"fetching-more\");\n            return self.fetch(options).always(function() {\n                self.trigger(\"fetching-more-done\");\n            });\n        },\n\n        fetchCurrentPage: function(options) {\n            return this.fetchPage(this.currentPage, options);\n        },\n\n        fetchPrevPage: function(options) {\n            return this.fetchPage(this.currentPage - 1, options);\n        },\n\n        fetchNextPage: function(options) {\n            return this.fetchPage(this.currentPage + 1, options);\n        }\n    });\n\n    //=============================================================================\n    /**\n * A Collection that will load more elements without reseting.\n */\n    var InfinitelyScrollingCollection = ControlledFetchCollection.extend({\n        /** @type {Number} limit used for the first fetch (or a reset) */\n        limitOnFirstFetch: null,\n        /** @type {Number} limit used for each subsequent fetch */\n        limitPerFetch: 100,\n\n        initialize: function(models, options) {\n            ControlledFetchCollection.prototype.initialize.call(\n                this,\n                models,\n                options\n            );\n            /** @type {Integer} number of contents to return from the first fetch */\n            this.limitOnFirstFetch =\n                options.limitOnFirstFetch || this.limitOnFirstFetch;\n            /** @type {Integer} limit for every fetch after the first */\n            this.limitPerFetch = options.limitPerFetch || this.limitPerFetch;\n            /** @type {Boolean} are all contents fetched? */\n            this.allFetched = false;\n            /** @type {Integer} what was the offset of the last content returned */\n            this.lastFetched = options.lastFetched || 0;\n        },\n\n        /** build ajax data/parameters from options */\n        _buildFetchOptions: function(options) {\n            // options (options for backbone.fetch and jquery.ajax generally)\n            // backbone option; false here to make fetching an addititive process\n            options.remove = options.remove || false;\n            return ControlledFetchCollection.prototype._buildFetchOptions.call(\n                this,\n                options\n            );\n        },\n\n        /** fetch the first 'page' of data */\n        fetchFirst: function(options) {\n            Galaxy.debug(\"ControlledFetchCollection.fetchFirst:\", options);\n            options = options ? _.clone(options) : {};\n            this.allFetched = false;\n            this.lastFetched = 0;\n            return this.fetchMore(\n                _.defaults(options, {\n                    reset: true,\n                    limit: this.limitOnFirstFetch\n                })\n            );\n        },\n\n        /** fetch the next page of data */\n        fetchMore: function(options) {\n            Galaxy.debug(\"ControlledFetchCollection.fetchMore:\", options);\n            options = _.clone(options || {});\n            var collection = this;\n\n            Galaxy.debug(\"fetchMore, options.reset:\", options.reset);\n            if (!options.reset && collection.allFetched) {\n                return jQuery.when();\n            }\n\n            // TODO: this fails in the edge case where\n            //  the first fetch offset === limit (limit 4, offset 4, collection.length 4)\n            if (options.reset) {\n                options.offset = 0;\n            } else if (options.offset === undefined) {\n                options.offset = collection.lastFetched;\n            }\n            var limit = (options.limit =\n                options.limit || collection.limitPerFetch || null);\n            Galaxy.debug(\"fetchMore, limit:\", limit, \"offset:\", options.offset);\n\n            collection.trigger(\"fetching-more\");\n            return (\n                collection\n                    .fetch(options)\n                    .always(function() {\n                        collection.trigger(\"fetching-more-done\");\n                    })\n                    // maintain allFetched flag and trigger if all were fetched this time\n                    .done(function _postFetchMore(fetchedData) {\n                        var numFetched = _.isArray(fetchedData)\n                            ? fetchedData.length\n                            : 0;\n                        collection.lastFetched += numFetched;\n                        Galaxy.debug(\n                            \"fetchMore, lastFetched:\",\n                            collection.lastFetched\n                        );\n                        // anything less than a full page means we got all there is to get\n                        if (!limit || numFetched < limit) {\n                            collection.allFetched = true;\n                            collection.trigger(\"all-fetched\", this);\n                        }\n                    })\n            );\n        },\n\n        /** fetch all the collection */\n        fetchAll: function(options) {\n            // whitelist options to prevent allowing limit/offset/filters\n            // (use vanilla fetch instead)\n            options = options || {};\n            var self = this;\n            options = _.pick(options, \"silent\");\n            options.filters = {};\n            return self.fetch(options).done(function() {\n                self.allFetched = true;\n                self.trigger(\"all-fetched\", self);\n            });\n        }\n    });\n\n    //==============================================================================\n    return {\n        ControlledFetchCollection: ControlledFetchCollection,\n        PaginatedCollection: PaginatedCollection,\n        InfinitelyScrollingCollection: InfinitelyScrollingCollection\n    };\n});\n"]}